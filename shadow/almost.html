<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forma Base - Final Logic</title>
    <link rel="manifest" href="manifest.json"> 
    <style>
        body {
            user-select: none; 
            margin: 0;
            overflow: hidden;
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            background: #000;
        }

        .control-button, .top-control, .mid-control {
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            width: auto;
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9) !important; 
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            padding: 0;
            background: none;

        }

        .control-button { bottom: 20px; }
        .further-button { left: 3%; right: auto; } 
        .closer-button { right: 3%; left: auto; } 
        .fly-button { left: 50%; transform: translateX(-50%); }

        .top-control { top: 20px; }
        .load-button { left: 3%; transform: none; } 
        .reset-button { left: 50%; transform: translateX(-50%); }
        .save-button { right: 3%; left: auto; transform: none; } 

        .mid-control { top: 50%; transform: translateY(-50%); }
        .help-button { text-decoration: none; left: 3%; }
        .shadows-button { right: 3%; }
            
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="control-button further-button">Further</div> 
    <div class="control-button closer-button">Closer</div> 
    <div class="control-button fly-button">Fly</div> 
    
    <div class="top-control load-button">Load (Disabled)</div> 
    <div class="top-control reset-button">Reset</div> 
    <div class="top-control save-button">Save (Disabled)</div> 

    <a class="mid-control help-button" href="https://t.me/eqlectika/178" target="_blank">Help</a> 
    <div class="mid-control shadows-button">Shadow</div> 
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// --- Imports & Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30; 

let previousCameraPosition = new THREE.Vector3().copy(camera.position);

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.shadowMap.enabled = true; 
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Настройки полета ---
let isFlying = false;
let currentSpeed = 0.0;             
const MAX_SPEED = 0.3;              
const ACCELERATION = 0.00033;       
const DECCELERATION = 0.00033;      

// --- Background Animation ---
const colors = ['#006ee5', '#000033'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 60; 
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000); 

// --- Controls & Lights ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;
controls.enableZoom = true; 
controls.zoomSpeed = 0.5; 
controls.enablePan = true;
controls.panSpeed = 0.3;  

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
scene.add(ambientLight);
const cameraLightGroup = new THREE.Group();
camera.add(cameraLightGroup); 
scene.add(camera); 
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
directionalLight.position.set(0, 0, 10); 
directionalLight.castShadow = true; 
directionalLight.shadow.mapSize.width = 2048; 
directionalLight.shadow.mapSize.height = 2048; 
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 50; 
directionalLight.shadow.camera.left = -50; 
directionalLight.shadow.camera.right = 50; 
directionalLight.shadow.camera.top = 50; 
directionalLight.shadow.camera.bottom = -50;
cameraLightGroup.add(directionalLight);
const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 1.0);
ultramarineLight.position.set(0, 0, -10); 
ultramarineLight.castShadow = false; 
cameraLightGroup.add(ultramarineLight);

// --- Object Logic (Core Geometry Setup and Helpers) ---
let formaCubeFaces = []; 
const collisionRaycaster = new THREE.Raycaster();
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 
function addInternalLights(group) {
    const warmInternalLight = new THREE.PointLight(0xffaa00, 0.01, 0); 
    warmInternalLight.position.set(0, 0, 0); 
    group.add(warmInternalLight);
}
const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },     
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },     
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },     
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },     
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },               
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },       
];

const getTunnelFaceId = (normal) => {
    const inverseNormal = normal.clone().negate();
    let bestMatchId = -1;
    let maxDot = -Infinity; 
    FACE_CONFIGS.forEach(config => {
        const dot = config.normal.dot(inverseNormal); 
        if (dot > maxDot) {
            maxDot = dot;
            bestMatchId = config.id;
        }
    });
    return bestMatchId;
};

const createCubeFace = (config) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshStandardMaterial({
        color: config.color, 
        roughness: 0.5,      
        metalness: 1.0,      
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 1.0,        
        envMap: scene.background, 
    });
    
    const face = new THREE.Mesh(faceGeometry, material);
    face.castShadow = true;   
    face.receiveShadow = true; 
    face.position.set(...config.pos);
    face.rotation.set(...config.rot);
    face.name = `face_${config.id}`; 
    face.userData = { 
        id: config.id, 
        originalColor: config.color,
        isTransparent: false
    };
    return face;
}

// --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ СТЫКОВКИ (Основаны на Позиции) ---

const getCubeGroupAtPosition = (position) => {
    let targetCube = null;
    scene.children.some((object) => {
        if (object.userData.isFormaCube && object.position.distanceTo(position) < 0.1) {
            targetCube = object;
            return true;
        }
        return false;
    });
    return targetCube;
};

/**
 * Удаляет грань из куба, находящуюся на стыке с направлением worldNormal.
 * @ПАРИТЕТ_ТРЕБОВАНИЯ: Обеспечивает удаление СУЩЕСТВУЮЩЕЙ грани.
 */
const removeFaceFromCubeByNormal = (cubeGroup, worldNormal) => {
    let faceRemoved = null;
    cubeGroup.children.some(child => {
        if (!child.isMesh) return false;
        
        const faceNormalLocal = child.geometry.attributes.normal.array.slice(0, 3);
        const faceNormalWorld = new THREE.Vector3(faceNormalLocal[0], faceNormalLocal[1], faceNormalLocal[2]).transformDirection(child.matrixWorld);
        
        const inverseNormal = worldNormal.clone().negate();

        if (faceNormalWorld.dot(inverseNormal) > 0.99) {
            const index = formaCubeFaces.indexOf(child);
            if (index > -1) formaCubeFaces.splice(index, 1);

            cubeGroup.remove(child);
            child.geometry.dispose();
            faceRemoved = child;
            return true;
        }
        return false;
    });
    
    if (cubeGroup.children.length === 1 && cubeGroup.children[0].isLight) {
        scene.remove(cubeGroup);
    }
    return faceRemoved;
}
// ----------------------------------------------------


/**
 * Создает куб, исключая грани, которые находятся в местах стыка с другими кубами.
 * @ПАРИТЕТ_ТРЕБОВАНИЯ: Обеспечивает, что НОВАЯ грань не создается.
 */
const createFormaCube = (position, excludeIndex = -1, loadedFacesState = FACE_CONFIGS) => {
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);
    newFormaCubeGroup.userData.isFormaCube = true;

    const excludeIds = new Set();
    if (excludeIndex !== -1) {
        excludeIds.add(excludeIndex); // Исключаем грань, ведущую к старому кубу
    }

    // Проверяем 6 направлений: если сосед есть, грань, направленная в ту сторону, НЕ создается.
    FACE_CONFIGS.forEach((baseConfig) => {
        const localNormal = baseConfig.normal;
        
        const neighborPosition = position.clone().add(localNormal.clone().multiplyScalar(CUBE_SIZE));
        
        if (getCubeGroupAtPosition(neighborPosition)) {
            // Если позиция занята, грань, направленная туда, не создается.
            excludeIds.add(baseConfig.id);
        }
    });

    // Создаем куб, исключая все найденные ID
    FACE_CONFIGS.forEach((baseConfig) => {
        if (excludeIds.has(baseConfig.id)) {
            return; 
        }
        
        const faceState = loadedFacesState.find(f => f.id === baseConfig.id);
        if (loadedFacesState !== FACE_CONFIGS && !faceState) return;

        const face = createCubeFace(baseConfig);
        
        if (faceState && faceState.isTransparent) {
             face.material.opacity = 0.5;
             face.material.envMapIntensity = 0.5;
             face.userData.isTransparent = true;
        }
        
        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    addInternalLights(newFormaCubeGroup); 
    return newFormaCubeGroup;
};


const clearWorld = () => {
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            object.children.filter(child => child.isLight).forEach(light => object.remove(light));
            scene.remove(object);
            object.children.forEach(mesh => {
                if (mesh.isMesh) {
                    mesh.geometry.dispose();
                    if (mesh.material.length) {
                        mesh.material.forEach(m => m.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
        }
    });
    formaCubeFaces = [];
    formaCubeGroup = null;
}

// Заглушка для loadLocalState, чтобы избежать ошибок.
const loadLocalState = () => false;

const initFormaCube = (position = new THREE.Vector3(0, 0, camera.position.z - 15)) => {
    clearWorld(); 
    const localLoaded = loadLocalState(); // Всегда false
    if (!localLoaded) {
        formaCubeGroup = createFormaCube(position, -1); 
    }
    controls.target.set(camera.position.x, camera.position.y, camera.position.z - 15); 
    controls.update();
    
    previousCameraPosition.copy(camera.position);
};


// --- Interactions (Unchanged) ---
let longPressTimer;
const LONG_PRESS_DELAY = 700; 
let isLongPress = false;
let lastTransparentFace = null; 
let longPressFired = false; 

const MOVE_THRESHOLD = 10; 
let pointerDownPosition = new THREE.Vector2(); 


renderer.domElement.addEventListener('pointerdown', (event) => {
    if (event.target.closest('.control-button, .top-control, .mid-control')) return;
    if (event.pointerType === 'mouse' && event.button !== 0) return;
    
    longPressFired = false;
    pointerDownPosition.set(event.clientX, event.clientY); 
    
    isLongPress = false;
    clearTimeout(longPressTimer);
    
    longPressTimer = setTimeout(() => {
        const currentUpPosition = new THREE.Vector2(event.clientX, event.clientY);
        const moveDistance = pointerDownPosition.distanceTo(currentUpPosition);

        if (moveDistance <= MOVE_THRESHOLD) { 
            isLongPress = true;
            longPressFired = true;
            handleTransparentToggle(event); 
        }
    }, LONG_PRESS_DELAY);
});

renderer.domElement.addEventListener('pointerup', (event) => {
    if (event.pointerType === 'mouse' && event.button !== 0) return;
    
    clearTimeout(longPressTimer); 
    
    const clientX = event.clientX;
    const clientY = event.clientY;
    const currentUpPosition = new THREE.Vector2(clientX, clientY);

    const moveDistance = pointerDownPosition.distanceTo(currentUpPosition);
    if (moveDistance > MOVE_THRESHOLD) { 
        isLongPress = false;
        longPressFired = false;
        return;
    }

    if (longPressFired) {
        isLongPress = false;
        longPressFired = false;
        return;
    }
    
    if (!isLongPress) {
        const intersects = getIntersection(event);
        if (intersects.length > 0) {
            const face = intersects[0].object;
            
            if (face.userData.isTransparent && face === lastTransparentFace) {
                 handleDeleteAndCreateTunnel(event, face, intersects[0]); 
                 lastTransparentFace = null; 
            } 
        }
    }
    
    isLongPress = false;
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (longPressTimer) {
        const dist = pointerDownPosition.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
        if (dist > MOVE_THRESHOLD) { 
            clearTimeout(longPressTimer);
            isLongPress = false;
            longPressFired = false;
        }
    }
});

const resetPointers = () => {
    clearTimeout(longPressTimer);
    isLongPress = false;
    longPressFired = false;
};
renderer.domElement.addEventListener('pointercancel', resetPointers);
renderer.domElement.addEventListener('pointerleave', resetPointers);


const getIntersection = (event) => {
    const clientX = event.clientX; 
    const clientY = event.clientY;
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    return raycaster.intersectObjects(formaCubeFaces, false);
};

// --- ФУНКЦИИ ЖЕСТОВ (с логикой Стыковки) ---

const handleTransparentToggle = (event) => {
    const intersects = getIntersection(event);
    if (intersects.length > 0) {
        const face = intersects[0].object;
        
        if (face.material.opacity === 1.0) {
            face.material.opacity = 0.5;
            face.material.envMapIntensity = 0.5; 
            face.userData.isTransparent = true;
            lastTransparentFace = face; 
        } else {
            face.material.opacity = 1.0;
            face.material.envMapIntensity = 1.0; 
            face.userData.isTransparent = false;
            if (lastTransparentFace === face) {
                lastTransparentFace = null;
            }
        }
        face.material.needsUpdate = true;
    } else {
        lastTransparentFace = null;
    }
};

/**
 * Удаляет грань на старом кубе и создает новый куб.
 * Обеспечивает удаление всех стыковочных граней у всех соседей,
 * в соответствии с правилом: существующая удаляется, новая не создается.
 */
const handleDeleteAndCreateTunnel = (event, faceToDelete, intersection) => {
    const obj = faceToDelete;
    const group = obj.parent; 

    // 1. Подготовка данных
    const faceNormal = intersection.face.normal.clone();
    faceNormal.transformDirection(obj.matrixWorld); 
    faceNormal.normalize();
    
    const groupWorldPos = group.position.clone();
    const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
    
    // ПРОВЕРКА 1: Нельзя удалять/создавать тоннель, если место нового куба занято
    if (getCubeGroupAtPosition(newGroupPosition)) {
        obj.material.opacity = 1.0;
        obj.material.envMapIntensity = 1.0; 
        obj.userData.isTransparent = false;
        lastTransparentFace = null;
        obj.material.needsUpdate = true;
        console.log("Действие отменено: Позиция стыковки уже занята.");
        return; 
    }
    
    // 2. Создание "Тоннеля" (нового куба)
    // Грань, смотрящая на соседей, НЕ создается внутри createFormaCube
    const excludeId = getTunnelFaceId(faceNormal);
    const newCube = createFormaCube(newGroupPosition, excludeId, FACE_CONFIGS);

    // 3. Удаление старой грани (открывает проход к новому кубу)
    if (group) {
        group.remove(obj); 
        obj.geometry.dispose(); 
    }
    const index = formaCubeFaces.indexOf(obj);
    if (index > -1) formaCubeFaces.splice(index, 1);
    
    if (group && group.children.length === 1 && group.children[0].isLight) {
        scene.remove(group);
        if (group === formaCubeGroup) formaCubeGroup = null;
    }
    
    // 4. УДАЛЕНИЕ СУЩЕСТВУЮЩИХ СТЫКОВОЧНЫХ ГРАНЕЙ У ВСЕХ СОСЕДЕЙ
    FACE_CONFIGS.forEach(config => {
        const localNormal = config.normal;
        
        const neighborPosition = newGroupPosition.clone().add(localNormal.clone().multiplyScalar(CUBE_SIZE));
        
        const neighborCube = getCubeGroupAtPosition(neighborPosition);
        
        if (neighborCube) {
            // Нормаль в мировых координатах, направленная от нового куба к соседу
            const worldNormal = localNormal.clone().transformDirection(new THREE.Matrix4().makeTranslation(newGroupPosition.x, newGroupPosition.y, newGroupPosition.z));

            // Удаляем грань на соседнем кубе, которая находится на месте стыка
            removeFaceFromCubeByNormal(neighborCube, worldNormal);
        }
    });
};


// --- Collision Logic (Unchanged) ---
function checkMovementCollision() { 
    if (formaCubeFaces.length === 0) return;

    const movementDirection = new THREE.Vector3();
    movementDirection.subVectors(camera.position, previousCameraPosition);
    
    const distanceMoved = movementDirection.length();

    if (distanceMoved < 0.001) return;

    movementDirection.normalize();

    collisionRaycaster.set(previousCameraPosition, movementDirection);
    collisionRaycaster.far = distanceMoved + 0.1; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const safeOffset = 0.1; 
        const safePosition = hit.point.clone().sub(movementDirection.multiplyScalar(safeOffset));
        
        camera.position.copy(safePosition);
    }

    previousCameraPosition.copy(camera.position);
}
const applyCameraRepulsion = (startPosition, direction, distanceToMove) => { 
    const safeDistance = 0.5; 
    if (formaCubeFaces.length === 0) return distanceToMove; 
    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 
    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    return Math.abs(distanceToMove); 
};
const moveCamera = (directionVector, distance) => { 
    const initialPosition = camera.position.clone();
    const direction = directionVector.clone().normalize();
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

// --- Button Logic (Simplified to avoid stubs) ---
const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const resetButton = document.querySelector('.reset-button'); 
const flyButton = document.querySelector('.fly-button');
const shadowsButton = document.querySelector('.shadows-button'); 

closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    moveCamera(direction, CUBE_SIZE); 
});

resetButton.addEventListener('click', () => {
    window.location.reload(); 
});

flyButton.addEventListener('click', () => {
    isFlying = !isFlying;
    flyButton.textContent = isFlying ? 'Stop' : 'Fly';
});

shadowsButton.addEventListener('click', () => {
    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
    directionalLight.castShadow = renderer.shadowMap.enabled; 
    shadowsButton.textContent = renderer.shadowMap.enabled ? 'Shadow' : 'Light';
});

// --- Animation Loop ---
const animate = () => {
    controls.update();
    checkMovementCollision();
    if (isFlying) {
        currentSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
        currentSpeed = Math.max(currentSpeed - DECCELERATION, 0.0);
    }
    if (currentSpeed > 0) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        moveCamera(direction, currentSpeed); 
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

initFormaCube();
animate();

    </script>
</body>
</html>
