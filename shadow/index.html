<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forma Base - Precise Button Visibility Logic</title>
    <link rel="manifest" href="manifest.json"> 
    <style>
        body {
            user-select: none; 
            margin: 0;
            overflow: hidden;
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            background: #000;
        }

        .control-button, .top-control, .mid-control {
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            width: auto;
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9) !important; 
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            padding: 0;
            background: none;

        }

        .control-button { bottom: 20px; }
        .further-button { left: 3%; right: auto; } 
        .closer-button { right: 3%; left: auto; } 
        .fly-button { left: 50%; transform: translateX(-50%); }

        .top-control { top: 20px; }
        .load-button { left: 3%; transform: none; } 
        .reset-button { left: 50%; transform: translateX(-50%); } 
        .save-button { right: 3%; left: auto; transform: none; } 

        .mid-control { top: 50%; transform: translateY(-50%); }
        .help-button { text-decoration: none; left: 3%; }
        .shadows-button { right: 3%; }
            
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="control-button further-button">Further</div> 
    <div class="control-button closer-button">Closer</div> 
    <div class="control-button fly-button">Fly</div> 
    
    <div class="top-control load-button">Load</div> 
    <div class="top-control reset-button hidden">Reset</div> 
    <div class="top-control save-button hidden">Save</div> 

    <a class="mid-control help-button" href="https://t.me/eqlectika/185" target="_blank">Help</a> 
    <div class="mid-control shadows-button">Shadow</div> 
    
    <input type="file" id="file-input" style="display: none;" accept=".json"> 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// --- Imports & Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30; 

let previousCameraPosition = new THREE.Vector3().copy(camera.position);

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.shadowMap.enabled = true; 
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª–µ—Ç–∞ ---
let isFlying = false;
let currentSpeed = 0.0;             
const MAX_SPEED = 0.3;              
const ACCELERATION = 0.00033;       
const DECCELERATION = 0.00033;      

// --- Background Animation (Unchanged) ---
const colors = ['#006ee5', '#000033'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 60; 
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000); 

// --- Controls & Lights (Unchanged) ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;
controls.enableZoom = true; 
controls.zoomSpeed = 0.5; 
controls.enablePan = true;
controls.panSpeed = 0.3;  

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
scene.add(ambientLight);
const cameraLightGroup = new THREE.Group();
camera.add(cameraLightGroup); 
scene.add(camera); 
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
directionalLight.position.set(0, 0, 10); 
directionalLight.castShadow = true; 
directionalLight.shadow.mapSize.width = 2048; 
directionalLight.shadow.mapSize.height = 2048; 
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 50; 
directionalLight.shadow.camera.left = -50; 
directionalLight.shadow.camera.right = 50; 
directionalLight.shadow.camera.top = 50; 
directionalLight.shadow.camera.bottom = -50;
cameraLightGroup.add(directionalLight);
const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 1.0);
ultramarineLight.position.set(0, 0, -10); 
ultramarineLight.castShadow = false; 
cameraLightGroup.add(ultramarineLight);

// --- Object Logic (Core Geometry Setup and Helpers) ---
let formaCubeFaces = []; 
const collisionRaycaster = new THREE.Raycaster();
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 
const STORAGE_KEY = 'formaCubeState';

function addInternalLights(group) {
    const warmInternalLight = new THREE.PointLight(0xffaa00, 0.01, 0); 
    warmInternalLight.position.set(0, 0, 0); 
    group.add(warmInternalLight);
}
const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },     
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },     
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },     
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },     
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },               
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },       
];

const getTunnelFaceId = (normal) => {
    const inverseNormal = normal.clone().negate();
    let bestMatchId = -1;
    let maxDot = -Infinity; 
    FACE_CONFIGS.forEach(config => {
        const dot = config.normal.dot(inverseNormal); 
        if (dot > maxDot) {
            maxDot = dot;
            bestMatchId = config.id;
        }
    });
    return bestMatchId;
};

const createCubeFace = (config) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshStandardMaterial({
        color: config.color, 
        roughness: 0.5,      
        metalness: 1.0,      
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 1.0,        
        envMap: scene.background, 
    });
    
    const face = new THREE.Mesh(faceGeometry, material);
    face.castShadow = true;   
    face.receiveShadow = true; 
    face.position.set(...config.pos);
    face.rotation.set(...config.rot);
    face.name = `face_${config.id}`; 
    face.userData = { 
        id: config.id, 
        originalColor: config.color,
        isTransparent: false 
    };
    return face;
}

// --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –°–¢–´–ö–û–í–ö–ò (–û—Å–Ω–æ–≤–∞–Ω—ã –Ω–∞ –ü–æ–∑–∏—Ü–∏–∏) ---

const getCubeGroupAtPosition = (position) => {
    let targetCube = null;
    scene.children.some((object) => {
        if (object.userData.isFormaCube && object.position.distanceTo(position) < 0.1) {
            targetCube = object;
            return true;
        }
        return false;
    });
    return targetCube;
};

/**
 * –£–¥–∞–ª—è–µ—Ç –≥—Ä–∞–Ω—å –∏–∑ –∫—É–±–∞, –Ω–∞—Ö–æ–¥—è—â—É—é—Å—è –Ω–∞ —Å—Ç—ã–∫–µ —Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º worldNormal.
 * @–ü–ê–†–ò–¢–ï–¢_–¢–†–ï–ë–û–í–ê–ù–ò–Ø: –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç **—É–¥–∞–ª–µ–Ω–∏–µ** –°–£–©–ï–°–¢–í–£–Æ–©–ï–ô –≥—Ä–∞–Ω–∏.
 */
const removeFaceFromCubeByNormal = (cubeGroup, worldNormal) => {
    let faceRemoved = null;
    cubeGroup.children.some(child => {
        if (!child.isMesh) return false;
        
        const faceNormalLocal = child.geometry.attributes.normal.array.slice(0, 3);
        const faceNormalWorld = new THREE.Vector3(faceNormalLocal[0], faceNormalLocal[1], faceNormalLocal[2]).transformDirection(child.matrixWorld);
        
        const inverseNormal = worldNormal.clone().negate();

        if (faceNormalWorld.dot(inverseNormal) > 0.99) {
            const index = formaCubeFaces.indexOf(child);
            if (index > -1) formaCubeFaces.splice(index, 1);

            cubeGroup.remove(child);
            child.geometry.dispose();
            faceRemoved = child;
            return true;
        }
        return false;
    });
    
    if (cubeGroup.children.length === 1 && cubeGroup.children[0].isLight) {
        scene.remove(cubeGroup);
    }
    return faceRemoved;
}

/**
 * –°–æ–∑–¥–∞–µ—Ç –∫—É–±, –∏—Å–∫–ª—é—á–∞—è –≥—Ä–∞–Ω–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –º–µ—Å—Ç–∞—Ö —Å—Ç—ã–∫–∞ —Å –¥—Ä—É–≥–∏–º–∏ –∫—É–±–∞–º–∏.
 * @–ü–ê–†–ò–¢–ï–¢_–¢–†–ï–ë–û–í–ê–ù–ò–Ø: –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç, —á—Ç–æ –ù–û–í–ê–Ø –≥—Ä–∞–Ω—å **–Ω–µ —Å–æ–∑–¥–∞–µ—Ç—Å—è (–∏—Å–∫–ª—é—á–µ–Ω–∏–µ)**.
 */
const createFormaCube = (position, excludeIndex = -1, facesToCreate = FACE_CONFIGS) => {
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);
    newFormaCubeGroup.userData.isFormaCube = true;

    const excludeIds = new Set();
    if (excludeIndex !== -1) {
        excludeIds.add(excludeIndex); // –ò—Å–∫–ª—é—á–∞–µ–º –≥—Ä–∞–Ω—å, –≤–µ–¥—É—â—É—é –∫ —Å—Ç–∞—Ä–æ–º—É –∫—É–±—É
    }

    if (facesToCreate === FACE_CONFIGS) {
        FACE_CONFIGS.forEach((baseConfig) => {
            const localNormal = baseConfig.normal;
            
            const neighborPosition = position.clone().add(localNormal.clone().multiplyScalar(CUBE_SIZE));
            
            if (getCubeGroupAtPosition(neighborPosition)) {
                excludeIds.add(baseConfig.id);
            }
        });
    }

    const activeFaces = facesToCreate === FACE_CONFIGS ? FACE_CONFIGS : facesToCreate;

    activeFaces.forEach((faceData) => {
        const baseConfig = FACE_CONFIGS.find(f => f.id === faceData.id || f.id === faceData.id);
        
        if (facesToCreate === FACE_CONFIGS && excludeIds.has(baseConfig.id)) {
            return; 
        }

        const face = createCubeFace(baseConfig);
        
        if (faceData.isTransparent) {
             face.material.opacity = 0.5;
             face.material.envMapIntensity = 0.5;
             face.userData.isTransparent = true;
        }
        
        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    addInternalLights(newFormaCubeGroup); 
    return newFormaCubeGroup;
};


const clearWorld = () => {
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            object.children.filter(child => child.isLight).forEach(light => object.remove(light));
            scene.remove(object);
            object.children.forEach(mesh => {
                if (mesh.isMesh) {
                    mesh.geometry.dispose();
                    if (mesh.material && mesh.material.length) {
                        mesh.material.forEach(m => m.dispose());
                    } else if (mesh.material) {
                        mesh.material.dispose();
                    }
                }
            });
        }
    });
    formaCubeFaces = [];
    formaCubeGroup = null;
}

// --- SAVE/LOAD CORE LOGIC ---

const getWorldData = () => {
    const world = [];
    scene.children.forEach(object => {
        if (object.userData.isFormaCube) {
            const faces = [];
            object.children.forEach(child => {
                if (child.isMesh) {
                    faces.push({
                        id: child.userData.id,
                        isTransparent: child.userData.isTransparent
                    });
                }
            });

            if (faces.length > 0) {
                world.push({
                    position: {
                        x: object.position.x,
                        y: object.position.y,
                        z: object.position.z,
                    },
                    faces: faces
                });
            }
        }
    });

    return {
        world: world,
        camera: {
            position: camera.position,
            target: controls.target 
        }
    };
};

const loadWorldFromFile = (data) => {
    clearWorld();

    data.world.forEach(cubeData => {
        const position = new THREE.Vector3(cubeData.position.x, cubeData.position.y, cubeData.position.z);
        createFormaCube(position, -1, cubeData.faces); 
    });

    if (data.camera) {
        camera.position.set(data.camera.position.x, data.camera.position.y, data.camera.position.z);
        controls.target.set(data.camera.target.x, data.camera.target.y, data.camera.target.z);
        controls.update();
        previousCameraPosition.copy(camera.position);
    }
    
    if (scene.children.filter(c => c.userData.isFormaCube).length === 0) {
        // –ï—Å–ª–∏ —Ñ–∞–π–ª –±—ã–ª –ø—É—Å—Ç—ã–º –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π –∫—É–±
        initFormaCube(new THREE.Vector3(0, 0, 0)); 
    }
    
    hasContent = true; 
    isContentModified = false; // –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏, —Å—Ü–µ–Ω–∞ –Ω–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–π
    updateButtonVisibility();
};

const saveLocalState = () => {
    const data = getWorldData();
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ.");
        isContentModified = false; // –ü–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è, —Å—Ü–µ–Ω–∞ –Ω–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–π
        updateButtonVisibility();
        return true;
    } catch (e) {
        console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è:", e);
        return false;
    }
};

const loadLocalState = () => {
    const savedState = localStorage.getItem(STORAGE_KEY);
    
    if (!savedState) {
        console.log("–õ–æ–∫–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.");
        return false;
    }
    
    try {
        const data = JSON.parse(savedState);
        
        if (!data || !data.world || !Array.isArray(data.world)) {
            throw new Error("–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ –Ω–µ–ø–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö.");
        }
        
        loadWorldFromFile(data); 
        console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞.");
        return true;
    } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è:", e.message);
        localStorage.removeItem(STORAGE_KEY); 
        return false; 
    }
};


const saveWorldToFile = () => {
    const data = getWorldData();
    const json = JSON.stringify(data, null, 2);
    
    // –°–æ–∑–¥–∞–µ–º Data URL, –∫–æ—Ç–æ—Ä—ã–π Safari –º–æ–∂–µ—Ç –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å.
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(json);

    // –°–æ–∑–¥–∞–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏.
    const a = document.createElement('a');
    a.href = dataUri;
    a.download = `forma-state.json`; 
    document.body.appendChild(a);
    
    // –≠—Ç–æ—Ç –∫–ª–∏–∫ –¥–æ–ª–∂–µ–Ω –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å –¥–∏–∞–ª–æ–≥ –∑–∞–≥—Ä—É–∑–∫–∏/–ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–∞ iOS.
    a.click();
    
    document.body.removeChild(a);

    console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ —Ñ–∞–π–ª.");
};

document.getElementById('file-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                loadWorldFromFile(data);
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –∏–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ñ–∞–π–ª–∞:", error);
                alert("–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.");
            }
        };
        reader.readAsText(file);
        
        event.target.value = null; 
    }
});


const initFormaCube = (position = new THREE.Vector3(0, 0, camera.position.z - 15)) => {
    clearWorld(); 
    const localLoaded = loadLocalState(); 
    
    if (!localLoaded || scene.children.filter(c => c.userData.isFormaCube).length === 0) {
        // –ß–∏—Å—Ç—ã–π –∑–∞–ø—É—Å–∫: –Ω–µ—Ç –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–ª–∏ –æ–Ω–æ –±—ã–ª–æ –ø—É—Å—Ç–æ–µ
        formaCubeGroup = createFormaCube(position, -1); 
        hasContent = false; // –ù–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è, —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω—ã–π –∫—É–±
        isContentModified = false; // –ù–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–æ
    } 
    
    controls.target.set(camera.position.x, camera.position.y, camera.position.z - 15); 
    controls.update();
    
    previousCameraPosition.copy(camera.position);
    updateButtonVisibility(); 
};


// --- Interactions ---
let longPressTimer;
const LONG_PRESS_DELAY = 700; 
let isLongPress = false;
let longPressFired = false; 

const MOVE_THRESHOLD = 10; 
let pointerDownPosition = new THREE.Vector2(); 


renderer.domElement.addEventListener('pointerdown', (event) => {
    if (event.target.closest('.control-button, .top-control, .mid-control')) return;
    if (event.pointerType === 'mouse' && event.button !== 0) return;
    
    longPressFired = false;
    pointerDownPosition.set(event.clientX, event.clientY); 
    
    isLongPress = false;
    clearTimeout(longPressTimer);
    
    longPressTimer = setTimeout(() => {
        const currentUpPosition = new THREE.Vector2(event.clientX, event.clientY);
        const moveDistance = pointerDownPosition.distanceTo(currentUpPosition);

        if (moveDistance <= MOVE_THRESHOLD) { 
            isLongPress = true;
            longPressFired = true;
            handleTransparentToggle(event); 
        }
    }, LONG_PRESS_DELAY);
});

renderer.domElement.addEventListener('pointerup', (event) => {
    if (event.pointerType === 'mouse' && event.button !== 0) return;
    
    clearTimeout(longPressTimer); 
    
    const clientX = event.clientX;
    const clientY = event.clientY;
    const currentUpPosition = new THREE.Vector2(clientX, clientY);

    const moveDistance = pointerDownPosition.distanceTo(currentUpPosition);
    if (moveDistance > MOVE_THRESHOLD) { 
        isLongPress = false;
        longPressFired = false;
        return;
    }

    if (longPressFired) {
        isLongPress = false;
        longPressFired = false;
        return;
    }
    
    // –õ–û–ì–ò–ö–ê –ö–û–†–û–¢–ö–û–ì–û –ö–õ–ò–ö–ê
    if (!isLongPress) {
        const intersects = getIntersection(event);

        if (intersects.length > 0) {
            const face = intersects[0].object;
            
            // –ü–†–û–í–ï–†–ö–ê: –ö—É–± —Å–æ–∑–¥–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –ì–†–ê–ù–¨ –ü–†–û–ó–†–ê–ß–ù–ê–Ø
            if (face.userData.isTransparent) {
                 handleDeleteAndCreateTunnel(event, face, intersects[0]); 
            } 
        }
    }
    
    isLongPress = false;
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (longPressTimer) {
        const dist = pointerDownPosition.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
        if (dist > MOVE_THRESHOLD) { 
            clearTimeout(longPressTimer);
            isLongPress = false;
            longPressFired = false;
        }
    }
});

const resetPointers = () => {
    clearTimeout(longPressTimer);
    isLongPress = false;
    longPressFired = false;
};
renderer.domElement.addEventListener('pointercancel', resetPointers);
renderer.domElement.addEventListener('pointerleave', resetPointers);


const getIntersection = (event) => {
    const clientX = event.clientX; 
    const clientY = event.clientY;
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    return raycaster.intersectObjects(formaCubeFaces, false);
};

// --- –§–£–ù–ö–¶–ò–ò –ñ–ï–°–¢–û–í (—Å –ª–æ–≥–∏–∫–æ–π –°—Ç—ã–∫–æ–≤–∫–∏) ---

const handleTransparentToggle = (event) => {
    const intersects = getIntersection(event);
    if (intersects.length > 0) {
        const face = intersects[0].object;
        
        if (face.material.opacity === 1.0) {
            // –î–µ–ª–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–π
            face.material.opacity = 0.5;
            face.material.envMapIntensity = 0.5; 
            face.userData.isTransparent = true; 
        } else {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
            face.material.opacity = 1.0;
            face.material.envMapIntensity = 1.0; 
            face.userData.isTransparent = false;
        }
        face.material.needsUpdate = true;
        
        hasContent = true; // –°—Ü–µ–Ω–∞ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–∞
        isContentModified = true; 
        updateButtonVisibility();
    } 
};

/**
 * –£–¥–∞–ª—è–µ—Ç –≥—Ä–∞–Ω—å –Ω–∞ —Å—Ç–∞—Ä–æ–º –∫—É–±–µ –∏ —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –∫—É–±.
 */
const handleDeleteAndCreateTunnel = (event, faceToDelete, intersection) => {
    const obj = faceToDelete;
    const group = obj.parent; 

    // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    const faceNormal = intersection.face.normal.clone();
    faceNormal.transformDirection(obj.matrixWorld); 
    faceNormal.normalize();
    
    const groupWorldPos = group.position.clone();
    const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
    
    if (getCubeGroupAtPosition(newGroupPosition)) {
        console.log("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ: –ü–æ–∑–∏—Ü–∏—è —Å—Ç—ã–∫–æ–≤–∫–∏ —É–∂–µ –∑–∞–Ω—è—Ç–∞.");
        return; 
    }
    
    // 2. –°–æ–∑–¥–∞–Ω–∏–µ "–¢–æ–Ω–Ω–µ–ª—è" (–Ω–æ–≤–æ–≥–æ –∫—É–±–∞) - –ù–µ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –≥—Ä–∞–Ω–∏
    const excludeId = getTunnelFaceId(faceNormal);
    const newCube = createFormaCube(newGroupPosition, excludeId, FACE_CONFIGS);

    // 3. –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–π –≥—Ä–∞–Ω–∏ (–æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø—Ä–æ—Ö–æ–¥ –∫ –Ω–æ–≤–æ–º—É –∫—É–±—É) - –£–¥–∞–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –≥—Ä–∞–Ω–∏
    if (group) {
        group.remove(obj); 
        obj.geometry.dispose(); 
    }
    const index = formaCubeFaces.indexOf(obj);
    if (index > -1) formaCubeFaces.splice(index, 1);
    
    if (group && group.children.length === 1 && group.children[0].isLight) {
        scene.remove(group);
        if (group === formaCubeGroup) formaCubeGroup = null;
    }
    
    // 4. –£–î–ê–õ–ï–ù–ò–ï –°–£–©–ï–°–¢–í–£–Æ–©–ò–• –°–¢–´–ö–û–í–û–ß–ù–´–• –ì–†–ê–ù–ï–ô –£ –í–°–ï–• –°–û–°–ï–î–ï–ô 
    FACE_CONFIGS.forEach(config => {
        const localNormal = config.normal;
        
        const neighborPosition = newGroupPosition.clone().add(localNormal.clone().multiplyScalar(CUBE_SIZE));
        
        const neighborCube = getCubeGroupAtPosition(neighborPosition);
        
        if (neighborCube) {
            const worldNormal = localNormal.clone().transformDirection(new THREE.Matrix4().makeTranslation(newGroupPosition.x, newGroupPosition.y, newGroupPosition.z));

            removeFaceFromCubeByNormal(neighborCube, worldNormal);
        }
    });
    
    saveLocalState(); 
    hasContent = true; // –°—Ü–µ–Ω–∞ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–∞
    isContentModified = true; 
    updateButtonVisibility();
};


// --- Collision Logic (Unchanged) ---
function checkMovementCollision() { 
    if (formaCubeFaces.length === 0) return;

    const movementDirection = new THREE.Vector3();
    movementDirection.subVectors(camera.position, previousCameraPosition);
    
    const distanceMoved = movementDirection.length();

    if (distanceMoved < 0.001) return;

    movementDirection.normalize();

    collisionRaycaster.set(previousCameraPosition, movementDirection);
    collisionRaycaster.far = distanceMoved + 0.1; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const safeOffset = 0.1; 
        const safePosition = hit.point.clone().sub(movementDirection.multiplyScalar(safeOffset));
        
        camera.position.copy(safePosition);
    }

    previousCameraPosition.copy(camera.position);
}
const applyCameraRepulsion = (startPosition, direction, distanceToMove) => { 
    const safeDistance = 0.5; 
    if (formaCubeFaces.length === 0) return distanceToMove; 
    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 
    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    return Math.abs(distanceToMove); 
};
const moveCamera = (directionVector, distance) => { 
    const initialPosition = camera.position.clone();
    const direction = directionVector.clone().normalize();
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

// --- Button Logic ---
const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const resetButton = document.querySelector('.reset-button'); 
const flyButton = document.querySelector('.fly-button');
const shadowsButton = document.querySelector('.shadows-button'); 
const saveButton = document.querySelector('.save-button');
const loadButton = document.querySelector('.load-button');
const fileInput = document.getElementById('file-input');

let hasContent = false; 
let isContentModified = false; 

// üö® –§–£–ù–ö–¶–ò–Ø: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç—å—é –∫–Ω–æ–ø–æ–∫ Load/Save/Reset
const updateButtonVisibility = () => {
    // Load Button: –í–∏–¥–Ω–∞, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –∏–ª–∏ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (–ß–∏—Å—Ç—ã–π —Å—Ç–∞—Ä—Ç)
    if (hasContent) {
        loadButton.classList.add('hidden');
    } else {
        loadButton.classList.remove('hidden'); 
    }

    // Reset Button: –í–∏–¥–Ω–∞, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è —Å–±—Ä–æ—Å–∞ (–∑–∞–≥—Ä—É–∂–µ–Ω –∏–ª–∏ –∏–∑–º–µ–Ω–µ–Ω)
    if (hasContent) {
        resetButton.classList.remove('hidden');
    } else {
        resetButton.classList.add('hidden');
    }
    
    // Save Button: –í–∏–¥–Ω–∞, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç –±—ã–ª –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏
    if (isContentModified) {
        saveButton.classList.remove('hidden');
    } else {
        saveButton.classList.add('hidden');
    }
};


closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    moveCamera(direction, CUBE_SIZE); 
});

// –ö–û–†–†–ï–ö–¢–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø RESET
resetButton.addEventListener('click', () => {
    // –í—ã–ø–æ–ª–Ω—è–µ—Ç **—É–¥–∞–ª–µ–Ω–∏–µ** (deletion) —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ **–Ω–µ —Å–æ–∑–¥–∞–Ω–∏–µ (–∏—Å–∫–ª—é—á–µ–Ω–∏–µ)** —Å—Ü–µ–Ω—ã –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ
    localStorage.removeItem(STORAGE_KEY);
    window.location.reload(); 
});

flyButton.addEventListener('click', () => {
    isFlying = !isFlying;
    flyButton.textContent = isFlying ? 'Stop' : 'Fly';
});

shadowsButton.addEventListener('click', () => {
    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
    directionalLight.castShadow = renderer.shadowMap.enabled; 
    shadowsButton.textContent = renderer.shadowMap.enabled ? 'Shadow' : 'Light';
});

saveButton.addEventListener('click', () => {
    saveLocalState(); 
    saveWorldToFile();
});

loadButton.addEventListener('click', () => {
    // –û—á–∏—Å—Ç–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –ø–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –ø—Ä–∏ —Ä—É—á–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–µ
    localStorage.removeItem(STORAGE_KEY); 
    clearWorld();
    fileInput.click();
    // hasContent/isContentModified —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è –≤ loadWorldFromFile –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
});


// --- Animation Loop (Unchanged) ---
const animate = () => {
    controls.update();
    checkMovementCollision();
    if (isFlying) {
        currentSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
        currentSpeed = Math.max(currentSpeed - DECCELERATION, 0.0);
    }
    if (currentSpeed > 0) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        moveCamera(direction, currentSpeed); 
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

initFormaCube();
animate();

    </script>
</body>
</html>
