<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Forma Base - Tunneling Final Confirmed</title>
    <link rel="manifest" href="manifest.json"> 
    <style>
        body {
            user-select: none; 
            margin: 0;
            overflow: hidden;
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            background: #000;
        }

        .control-button, .top-control, .mid-control {
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            width: auto;
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9) !important; 
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            padding: 0;
            background: none;

        }

        /* Further, Closer, Fly/Stop - Нижний блок */
        .control-button { bottom: 20px; }
        .further-button { left: 3%; right: auto; } 
        .closer-button { right: 3%; left: auto; } 
        .fly-button { left: 50%; transform: translateX(-50%); }

        /* Load, Reset, Save - Верхний блок */
        .top-control { top: 20px; }
        .load-button { left: 3%; transform: none; } 
        .reset-button { left: 50%; transform: translateX(-50%); }
        .save-button { right: 3%; left: auto; transform: none; } 

        /* Help, Shadows - Средний блок */
        .mid-control { top: 50%; transform: translateY(-50%); }
        .help-button { text-decoration: none; left: 3%; }
        .shadows-button { right: 3%; }
            
        .hidden { display: none; }
        .secret { 
            position: fixed;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 18px;
            color: white;
            text-decoration: none;
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            z-index: 1000;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="control-button further-button">Further</div> 
    <div class="control-button closer-button">Closer</div> 
    <div class="control-button fly-button">Fly</div> 
    
    <div class="top-control load-button">Load</div> 
    <div class="top-control reset-button">Reset</div> 
    <div class="top-control save-button">Save</div> 

    <a class="mid-control help-button" href="https://t.me/eqlectika/178" target="_blank">Help</a> 
    <div class="mid-control shadows-button">Shadow</div> 
    
    <input type="file" id="file-input" style="display: none;" accept=".json"> 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// --- Imports & Setup (Unchanged) ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30; 

let previousCameraPosition = new THREE.Vector3().copy(camera.position);

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.shadowMap.enabled = true; 
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Настройки полета (Unchanged) ---
let isFlying = false;
let currentSpeed = 0.0;             
const MAX_SPEED = 0.3;              
const ACCELERATION = 0.00033;       
const DECCELERATION = 0.00033;      

// --- Background Animation (Unchanged) ---
const colors = ['#006ee5', '#000033'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 60; 
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000); 

// --- Controls & Lights (Unchanged) ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;
controls.enableZoom = true; 
controls.zoomSpeed = 0.5; 
controls.enablePan = true;
controls.panSpeed = 0.3;  
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
scene.add(ambientLight);
const cameraLightGroup = new THREE.Group();
camera.add(cameraLightGroup); 
scene.add(camera); 
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
directionalLight.position.set(0, 0, 10); 
directionalLight.castShadow = true; 
directionalLight.shadow.mapSize.width = 2048; 
directionalLight.shadow.mapSize.height = 2048; 
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 50; 
directionalLight.shadow.camera.left = -50; 
directionalLight.shadow.camera.right = 50; 
directionalLight.shadow.camera.top = 50; 
directionalLight.shadow.camera.bottom = -50;
cameraLightGroup.add(directionalLight);
const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 1.0);
ultramarineLight.position.set(0, 0, -10); 
ultramarineLight.castShadow = false; 
cameraLightGroup.add(ultramarineLight);

// --- Object Logic (getTunnelFaceId is correct) ---
let formaCubeFaces = []; 
const activePoints = [];
const collisionRaycaster = new THREE.Raycaster();
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 
function addInternalLights(group) {
    const warmInternalLight = new THREE.PointLight(0xffaa00, 0.01, 0); 
    warmInternalLight.position.set(0, 0, 0); 
    group.add(warmInternalLight);
}
const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },     
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },     
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },     
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },     
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },               
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },       
];

/**
 * Ищет ID грани, нормаль которой противоположна заданной нормали (для создания тоннеля).
 * Это грань на новом кубе, которая смотрит на место удаленной грани на старом кубе.
 * @param {THREE.Vector3} normal - Нормаль удаляемой грани (старого куба) в мировых координатах.
 * @returns {number} ID грани, которую нужно исключить из нового куба.
 */
const getTunnelFaceId = (normal) => {
    // Нам нужна грань с нормалью, противоположной нормали удаляемой грани.
    const inverseNormal = normal.clone().negate();
    
    let bestMatchId = -1;
    let maxDot = -Infinity; 
    
    // Ищем грань с нормалью, которая максимально совпадает с INVERSE_NORMAL
    FACE_CONFIGS.forEach(config => {
        const dot = config.normal.dot(inverseNormal); 
        if (dot > maxDot) {
            maxDot = dot;
            bestMatchId = config.id;
        }
    });
    return bestMatchId;
};

const createCubeFace = (config) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshStandardMaterial({
        color: config.color, 
        roughness: 0.5,      
        metalness: 1.0,      
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 1.0,        
        envMap: scene.background, 
    });
    
    const face = new THREE.Mesh(faceGeometry, material);
    face.castShadow = true;   
    face.receiveShadow = true; 
    face.position.set(...config.pos);
    face.rotation.set(...config.rot);
    face.name = `face_${config.id}`; 
    face.userData = { 
        id: config.id, 
        originalColor: config.color,
        isTransparent: false
    };
    return face;
}

const createFormaCube = (position, excludeIndex = -1, loadedFacesState = FACE_CONFIGS) => {
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);
    newFormaCubeGroup.userData.isFormaCube = true;

    FACE_CONFIGS.forEach((baseConfig) => {
        if (baseConfig.id === excludeIndex) return;
        const faceState = loadedFacesState.find(f => f.id === baseConfig.id);
        if (loadedFacesState !== FACE_CONFIGS && !faceState) return;

        const face = createCubeFace(baseConfig);
        if (faceState && faceState.isTransparent) {
             face.material.opacity = 0.5;
             face.material.envMapIntensity = 0.5;
             face.userData.isTransparent = true;
        }
        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    addInternalLights(newFormaCubeGroup); 
    return newFormaCubeGroup;
};

const clearWorld = () => {
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            object.children.filter(child => child.isLight).forEach(light => object.remove(light));
            scene.remove(object);
            object.children.forEach(mesh => {
                if (mesh.isMesh) {
                    mesh.geometry.dispose();
                    if (mesh.material.length) {
                        mesh.material.forEach(m => m.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
        }
    });
    formaCubeFaces = [];
    formaCubeGroup = null;
}

const initFormaCube = (position = new THREE.Vector3(0, 0, camera.position.z - 15)) => {
    clearWorld(); 
    const localLoaded = loadLocalState();
    if (!localLoaded) {
        formaCubeGroup = createFormaCube(position, -1); 
    }
    controls.target.set(camera.position.x, camera.position.y, camera.position.z - 15); 
    controls.update();
    
    previousCameraPosition.copy(camera.position);
};

// --- Save/Load Logic (Omitted for brevity) ---
const getWorldData = () => { /* ... */ return { world: [], camera: {} }; };
const saveWorldToFile = () => { /* ... */ };
const loadWorldFromFile = (data) => { /* ... */ };
document.getElementById('file-input').addEventListener('change', (event) => { /* ... */ });
const loadLocalState = () => { /* ... */ return false; };


// --- Interactions (Final Logic) ---
let longPressTimer;
const LONG_PRESS_DELAY = 700; 
let isLongPress = false;
let lastTransparentFace = null; 
let longPressFired = false; 

const MOVE_THRESHOLD = 10; 
let pointerDownPosition = new THREE.Vector2(); 


renderer.domElement.addEventListener('pointerdown', (event) => {
    if (event.target.closest('.control-button, .top-control, .mid-control')) return;
    
    longPressFired = false;
    pointerDownPosition.set(event.clientX, event.clientY); 
    
    if (event.pointerType === 'mouse' && event.button === 2) {
        event.preventDefault();
    }
    
    isLongPress = false;
    clearTimeout(longPressTimer);
    
    longPressTimer = setTimeout(() => {
        const currentUpPosition = new THREE.Vector2(event.clientX, event.clientY);
        const moveDistance = pointerDownPosition.distanceTo(currentUpPosition);

        if (moveDistance <= MOVE_THRESHOLD) { 
            isLongPress = true;
            longPressFired = true;
            handleTransparentToggle(event); 
        }
    }, LONG_PRESS_DELAY);
});

renderer.domElement.addEventListener('pointerup', (event) => {
    clearTimeout(longPressTimer); 
    
    const clientX = event.clientX;
    const clientY = event.clientY;
    const currentUpPosition = new THREE.Vector2(clientX, clientY);

    // 1. ФИЛЬТР СДВИГА
    const moveDistance = pointerDownPosition.distanceTo(currentUpPosition);
    if (moveDistance > MOVE_THRESHOLD) { 
        isLongPress = false;
        longPressFired = false;
        return; 
    }

    if (longPressFired) {
        isLongPress = false;
        longPressFired = false;
        return;
    }
    
    // 2. Single Tap (быстрый)
    if (!isLongPress) {
        const intersects = getIntersection(event);
        if (intersects.length > 0) {
            const face = intersects[0].object;
            
            if (face.userData.isTransparent && face === lastTransparentFace) {
                 handleDeleteAndCreateTunnel(event, face, intersects[0]); 
                 lastTransparentFace = null; 
            } 
        }
    }
    
    isLongPress = false;
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (longPressTimer) {
        const dist = pointerDownPosition.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
        if (dist > MOVE_THRESHOLD) { 
            clearTimeout(longPressTimer);
            isLongPress = false;
            longPressFired = false;
        }
    }
});

const resetPointers = () => {
    clearTimeout(longPressTimer);
    isLongPress = false;
    longPressFired = false;
};
renderer.domElement.addEventListener('pointercancel', resetPointers);
renderer.domElement.addEventListener('pointerleave', resetPointers);


const getIntersection = (event) => {
    const clientX = event.clientX; 
    const clientY = event.clientY;
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    return raycaster.intersectObjects(formaCubeFaces, false);
};

// --- ФУНКЦИИ ЖЕСТОВ ---

const handleTransparentToggle = (event) => {
    const intersects = getIntersection(event);
    if (intersects.length > 0) {
        const face = intersects[0].object;
        
        // 1. Смена состояния
        if (face.material.opacity === 1.0) {
            // Делаем прозрачной (и запоминаем)
            face.material.opacity = 0.5;
            face.material.envMapIntensity = 0.5; 
            face.userData.isTransparent = true;
            lastTransparentFace = face; 
        } else {
            // Делаем непрозрачной (и сбрасываем запоминание)
            face.material.opacity = 1.0;
            face.material.envMapIntensity = 1.0; 
            face.userData.isTransparent = false;
            if (lastTransparentFace === face) {
                lastTransparentFace = null;
            }
        }
        face.material.needsUpdate = true;
    } else {
        lastTransparentFace = null;
    }
};

/**
 * Удаляет выбранную грань (физически) и создает новый куб, 
 * исключая ту грань, которая должна была бы соединиться с удаленной (создание тоннеля).
 */
const handleDeleteAndCreateTunnel = (event, faceToDelete, intersection) => {
    const obj = faceToDelete;
    const group = obj.parent; 

    // 1. Подготовка данных для нового куба
    // Получаем нормаль удаляемой грани в мировых координатах
    const faceNormal = intersection.face.normal.clone();
    faceNormal.transformDirection(obj.matrixWorld); 
    faceNormal.normalize();
    
    // Позиция нового куба - на расстоянии CUBE_SIZE в направлении нормали удаляемой грани
    const groupWorldPos = group.position.clone();
    const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
    
    // Исключаемая грань на НОВОМ кубе (которая смотрит на удаленный объект)
    const excludeId = getTunnelFaceId(faceNormal);
    
    // 2. Создание "Тоннеля" (нового куба с исключенной гранью)
    const newCube = createFormaCube(newGroupPosition, excludeId, FACE_CONFIGS);

    // 3. Удаление старой грани (ФИЗИЧЕСКОЕ УДАЛЕНИЕ ДЛЯ ПРОХОДИМОСТИ)
    if (group) {
        group.remove(obj); // Удаление из группы сцены
        obj.geometry.dispose(); // Очистка памяти геометрии
    }
    const index = formaCubeFaces.indexOf(obj);
    if (index > -1) formaCubeFaces.splice(index, 1); // <-- Удаление из списка коллизий!
    
    // Если группа, в которой была грань, стала пустой, удаляем и ее
    if (group && group.children.length === 1 && group.children[0].isLight) {
        scene.remove(group);
        if (group === formaCubeGroup) formaCubeGroup = null;
    }
};


// --- Collision Logic (Unchanged and crucial for walkthrough) ---
function checkMovementCollision() { 
    if (formaCubeFaces.length === 0) return;

    const movementDirection = new THREE.Vector3();
    movementDirection.subVectors(camera.position, previousCameraPosition);
    
    const distanceMoved = movementDirection.length();

    if (distanceMoved < 0.001) return;

    movementDirection.normalize();

    collisionRaycaster.set(previousCameraPosition, movementDirection);
    collisionRaycaster.far = distanceMoved + 0.1; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const safeOffset = 0.1; 
        const safePosition = hit.point.clone().sub(movementDirection.multiplyScalar(safeOffset));
        
        camera.position.copy(safePosition);
    }

    previousCameraPosition.copy(camera.position);
}
const applyCameraRepulsion = (startPosition, direction, distanceToMove) => { 
    const safeDistance = 0.5; 
    if (formaCubeFaces.length === 0) return distanceToMove; 
    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 
    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    return Math.abs(distanceToMove); 
};
const moveCamera = (directionVector, distance) => { 
    const initialPosition = camera.position.clone();
    const direction = directionVector.clone().normalize();
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

// --- Button Logic (Unchanged) ---
const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const resetButton = document.querySelector('.reset-button'); 
const flyButton = document.querySelector('.fly-button');
const saveButton = document.querySelector('.save-button'); 
const loadButton = document.querySelector('.load-button');
const fileInput = document.getElementById('file-input');
const shadowsButton = document.querySelector('.shadows-button'); 

closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    moveCamera(direction, CUBE_SIZE); 
});

resetButton.addEventListener('click', () => {
    localStorage.removeItem('forma_world_data_local'); 
    localStorage.removeItem('forma_camera_data_local');
    window.location.reload(); 
});

saveButton.addEventListener('click', saveWorldToFile); 
loadButton.addEventListener('click', () => { fileInput.click(); });

flyButton.addEventListener('click', () => {
    isFlying = !isFlying;
    flyButton.textContent = isFlying ? 'Stop' : 'Fly';
});

shadowsButton.addEventListener('click', () => {
    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
    directionalLight.castShadow = renderer.shadowMap.enabled; 
    shadowsButton.textContent = renderer.shadowMap.enabled ? 'Shadow' : 'Light';
});

// --- Animation Loop (Unchanged) ---
const animate = () => {
    controls.update();
    checkMovementCollision();
    if (isFlying) {
        currentSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
        currentSpeed = Math.max(currentSpeed - DECCELERATION, 0.0);
    }
    if (currentSpeed > 0) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        moveCamera(direction, currentSpeed); 
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

initFormaCube();
animate();

    </script>
</body>
</html>
