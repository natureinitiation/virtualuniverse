<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decentralized Levitation P2P Node</title>
    <style>
        body { font-family: "Courier New"; margin: 0; overflow: hidden; background: #000; color: white; }
        #control-panel { 
            position: fixed; 
            bottom: 50px; 
            left: 10px; 
            cursor: pointer;
            z-index: 1000; 
        }
        #control-panel > * { margin: 9px 9px; }
        #object-counter {
            position: fixed;
            bottom: 210px;
            left: 20px;
            z-index: 1000;
        }
        #help-link {
            position: fixed;
            bottom: 15px;
            left: 20px;
            z-index: 1000;
            color: white;
            text-decoration: none;
        }
        button { margin-top: 5px; }
    </style>
</head>
<body>
    <div id="control-panel">
        <p id="startNode">Start Node</p>
        <p id="connectNode">Connect to Node</p>
        <p id="toggleMode">Drop</p>
        <p id="toggleMovement">Move</p>
        <p id="withdrawButton">Withdraw</p>
    </div>
    <div id="object-counter">Tockens: 100</div>
    <a id="help-link" href="https://fromhe01.wp-tech01.gen.in/how-to-magic/" target="_blank">Help</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script>
        let nodeId = Math.random().toString(36).substr(2, 9);
        let peers = {};
        let objects = [];
        let selectedObject = null;
        let isThrowMode = true;
        let isFreeMode = false;
        let personalObjects = 100;
        let isMovingForward = false;

        // Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ WebGL Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¾Ð¹ Ð¾ÑˆÐ¸Ð±Ð¾Ðº
        let renderer;
        try {
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true // Ð”Ð»Ñ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ñ Linux
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        } catch (err) {
            alert("WebGL ERROR: " + err.message + "\nEnable hardware acceleration!");
            throw err;
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        // ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const blueLight = new THREE.DirectionalLight(0x0000ff, 1, 100);
        blueLight.position.set(10, 0, 0);
        scene.add(blueLight);
        const greenLight = new THREE.DirectionalLight(0x00ff00, 1, 100);
        greenLight.position.set(0, 10, 0);
        scene.add(greenLight);
        const redLight = new THREE.DirectionalLight(0xff0000, 1, 100);
        redLight.position.set(0, 0, 10);
        scene.add(redLight);

        // Ð”ÐµÑ†ÐµÐ½Ñ‚Ñ€Ð°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ PeerJS Ñ STUN
        const peer = new Peer(nodeId, {
            config: {
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:global.stun.twilio.com:3478?transport=udp" }
                ]
            },
            debug: 1
        });

        peer.on('open', (id) => {
            console.log('DECENTRALIZED NODE ID:', id);
        });

        peer.on('connection', (conn) => {
            
            console.log('Connected to peer:', conn.peer);
            conn.on('data', (data) => {
            console.log("ðŸ“¨ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ðµ:", data); // Ð›Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð²Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…

                if (data.type === 'objectCreated') {
                    syncObjects([data.object]);
                } else if (data.type === 'requestSync') {
                    conn.send({ type: 'syncObjects', objects });
                } else if (data.type === 'syncObjects') {
                    syncObjects(data.objects);
                } else if (data.type === 'objectDeleted') {
                    deleteObject(data.objectId);
                } else if (data.type === 'objectCollected') {
                    personalObjects++;
                    updateObjectCounter();
                }
            });
        });

        // BroadcastChannel Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ… Ð²ÐºÐ»Ð°Ð´Ð¾Ðº
        const localChannel = new BroadcastChannel('p2p-network');
        localChannel.onmessage = (e) => {
            if (e.data.type === 'objectDeleted') {
            deleteObject(e.data.objectId);
            } else if (e.data.type === 'sync') {
            syncObjects(e.data.objects);
            }
        };

        function startNode() {
            alert('Node started with ID: ' + nodeId);
        }

        function connectNode() {
            let targetNodeId = prompt('Enter node ID:');
            if (!targetNodeId) return;

            const conn = peer.connect(targetNodeId);
            conn.on('open', () => {
                peers[targetNodeId] = conn;
                conn.send({ type: 'requestSync' });
            });

            conn.on('data', (data) => {
                if (data.type === 'objectCreated') {
                    syncObjects([data.object]);
                } else if (data.type === 'syncObjects') {
                    syncObjects(data.objects);
                } else if (data.type === 'objectDeleted') {
                    deleteObject(data.objectId);
                } else if (data.type === 'objectCollected') {
                    personalObjects++;
                    updateObjectCounter();
                }
            });
        }

        function createObject() {
            if (personalObjects <= 0) {
                alert('No more objects available to throw.');
                return;
            }

            const vector = new THREE.Vector3(0, 0, -1);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = 10;
            const position = camera.position.clone().add(dir.multiplyScalar(distance));

            let object = {
                id: Math.random().toString(36).substr(2, 9),
                position: [position.x, position.y, position.z],
                color: Math.random() * 0xffffff,
                size: 3
            };
            objects.push(object);
            personalObjects--;
            renderObject(object);
            updateObjectCounter();

            Object.values(peers).forEach(conn => {
                conn.send({ type: 'objectCreated', object });
            });
            localChannel.postMessage({ type: 'sync', objects: [object] }); // Ð›Ð¾ÐºÐ°Ð»ÑŒÐ½Ð°Ñ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ
        }

        function deleteObject(objectId) {
            const index = objects.findIndex(obj => obj.id === objectId);
            if (index !== -1) {
                objects.splice(index, 1);
                const mesh = scene.children.find(child => child.userData.id === objectId);
                if (mesh) scene.remove(mesh);
                updateObjectCounter();
            }
        }

        function renderObject(object) {
            let geometry = new THREE.IcosahedronGeometry(object.size);
            let material = new THREE.MeshPhysicalMaterial({
                color: object.color,
                roughness: 0.4,
                metalness: 1,
                opacity: 0.7,
                transparent: true,
            });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(...object.position);
            mesh.userData.id = object.id;
            scene.add(mesh);
        }

        function syncObjects(newObjects) {
            newObjects.forEach(obj => {
                if (!objects.some(o => o.id === obj.id)) {
                    objects.push(obj);
                    renderObject(obj);
                    updateObjectCounter();
                }
            });
        }

        // ÐžÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ (updateObjectCounter, Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ñ, ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ) 
        function updateObjectCounter() {
            document.getElementById('object-counter').innerText = `Objects: ${personalObjects}`;
        }

        // Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÐºÐ°Ð¼ÐµÑ€Ð¾Ð¹ Ñ Ð¿Ð»Ð°Ð²Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð¸ Ð¸Ð½ÐµÑ€Ñ‚Ð½Ð¾ÑÑ‚ÑŒÑŽ
        let isDragging = false;
        let isRotating = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotationVelocity = { x: 0, y: 0 };
        let cameraPositionVelocity = { x: 0, y: 0, z: 0 };
        let cameraZoomVelocity = 0;
        const damping = 0.95; // Ð—Ð°Ð¼ÐµÐ´Ð»ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ð»Ð°Ð²Ð½Ð¾ÑÑ‚Ð¸

        document.addEventListener('mousedown', (event) => {
            if (event.button === 2) { // ÐŸÑ€Ð°Ð²Ð°Ñ ÐºÐ½Ð¾Ð¿ÐºÐ° Ð¼Ñ‹ÑˆÐ¸
                isDragging = true;
            } else if (event.button === 0) { // Ð›ÐµÐ²Ð°Ñ ÐºÐ½Ð¾Ð¿ÐºÐ° Ð¼Ñ‹ÑˆÐ¸
                isRotating = true;
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            isRotating = false;
        });

        document.addEventListener('mousemove', (event) => {
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            if (isDragging) {
                cameraPositionVelocity.x = -deltaX * 0.02;
                cameraPositionVelocity.y = deltaY * 0.02;
            } else if (isRotating) {
                cameraRotationVelocity.x = deltaY * 0.001; // ÐœÐµÐ´Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ð¾Ð²Ð¾Ñ€Ð¾Ñ‚
                cameraRotationVelocity.y = deltaX * 0.001; // ÐœÐµÐ´Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ð¾Ð²Ð¾Ñ€Ð¾Ñ‚
            }

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('wheel', (event) => {
            cameraZoomVelocity = event.deltaY * 0.005; // Ð£Ð¼ÐµÐ½ÑŒÑˆÐ¸Ð»Ð¸ ÑÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð¶ÐµÐ½Ð¸Ñ/Ð¾Ñ‚Ð´Ð°Ð»ÐµÐ½Ð¸Ñ
        });

        document.addEventListener('contextmenu', (event) => {
            event.preventDefault(); // ÐžÑ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð½Ð¾Ðµ Ð¼ÐµÐ½ÑŽ Ð´Ð»Ñ Ð¿Ñ€Ð°Ð²Ð¾Ð¹ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð¼Ñ‹ÑˆÐ¸
        });

        document.getElementById('startNode').addEventListener('click', startNode);
        document.getElementById('connectNode').addEventListener('click', connectNode);
        document.getElementById('toggleMode').addEventListener('click', () => {
            if (isFreeMode) {
                isFreeMode = false;
                isThrowMode = true;
                document.getElementById('toggleMode').innerText = 'Throw';
            } else if (isThrowMode) {
                isThrowMode = false;
                document.getElementById('toggleMode').innerText = 'Pick Up';
            } else {
                isFreeMode = true;
                document.getElementById('toggleMode').innerText = 'Free';
            }
        });

        // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð´Ð»Ñ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Go/Stop
        document.getElementById('toggleMovement').addEventListener('click', () => {
            isMovingForward = !isMovingForward;
            document.getElementById('toggleMovement').innerText = isMovingForward ? 'Stop' : 'Go';
        });
        
        document.getElementById('withdrawButton').addEventListener('click', async () => {
  const amount = prompt("Enter amount to withdraw:");
  const recipient = prompt("Enter Tron address (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€: TR8...):");

  if (amount > personalObjects) {
    alert("Insufficient balance!");
    return;
  }

  // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚Ð°
  const contract = await tronWeb.contract(CONTRACT_ABI, CONTRACT_ADDRESS);

  // Ð’Ñ‹Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¼ÐµÑ‚Ð¾Ð´ transfer
  try {
    await contract.transfer(recipient, amount * 10**18).send();
    personalObjects -= amount;
    updateObjectCounter();
    alert("Withdrawal successful!");
  } catch (error) {
    alert("Error: " + error.message);
  }
});

        window.addEventListener('click', (event) => {
            if (event.target.tagName !== 'BUTTON' && !isFreeMode) {
                if (isThrowMode) {
                    createObject();
                } else {
                    pickUpObject();
                }
            }
        });

        // Ð’Ñ‹Ð±Ð¾Ñ€ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð´Ð»Ñ Pick Up
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

function pickUpObject() {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length > 0) {
        const objectId = intersects[0].object.userData.id;
        deleteObject(objectId);
        personalObjects++;
        updateObjectCounter();

        // ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð²ÑÐµÐ¼ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ñ‹Ð¼ ÑƒÐ·Ð»Ð°Ð¼
        Object.values(peers).forEach(conn => {
            if (conn.open) { // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ
                conn.send({ type: 'objectDeleted', objectId: objectId });
                conn.send({ type: 'objectCollected' });
            }
        });

        // Ð›Ð¾ÐºÐ°Ð»ÑŒÐ½Ð°Ñ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ‡ÐµÑ€ÐµÐ· BroadcastChannel
        localChannel.postMessage({ 
            type: 'objectDeleted', 
            objectId: objectId 
        });
    }
}

        // ÐÐ½Ð¸Ð¼Ð°Ñ†Ð¸Ñ Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ñ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²
        function animateObjects() {
            objects.forEach(obj => {
                const mesh = scene.children.find(child => child.userData.id === obj.id);
                if (mesh) {
                    mesh.rotation.x += 0.01; // ÐœÐµÐ´Ð»ÐµÐ½Ð½Ð¾Ðµ Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ
                    mesh.rotation.y += 0.01; // ÐœÐµÐ´Ð»ÐµÐ½Ð½Ð¾Ðµ Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ
                }
            });
        }

        // Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¾Ñ‚Ñ‚Ð°Ð»ÐºÐ¸Ð²Ð°Ð½Ð¸Ñ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² Ð¾Ñ‚ ÐºÐ°Ð¼ÐµÑ€Ñ‹
        function repelObjectsFromCamera() {
            const repelDistance = 12; // Ð Ð°Ð´Ð¸ÑƒÑ Ð¾Ñ‚Ñ‚Ð°Ð»ÐºÐ¸Ð²Ð°Ð½Ð¸Ñ
            objects.forEach(obj => {
                const mesh = scene.children.find(child => child.userData.id === obj.id);
                if (mesh) {
                    const distance = mesh.position.distanceTo(camera.position);
                    if (distance < repelDistance) {
                        const direction = mesh.position.clone().sub(camera.position).normalize();
                        mesh.position.add(direction.multiplyScalar(repelDistance - distance));
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // ÐŸÐ»Ð°Ð²Ð½Ð¾Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ ÐºÐ°Ð¼ÐµÑ€Ñ‹
            camera.position.x += cameraPositionVelocity.x;
            camera.position.y += cameraPositionVelocity.y;
            camera.position.z += cameraPositionVelocity.z;
            cameraPositionVelocity.x *= damping;
            cameraPositionVelocity.y *= damping;
            cameraPositionVelocity.z *= damping;

            // ÐŸÐ»Ð°Ð²Ð½Ñ‹Ð¹ Ð¿Ð¾Ð²Ð¾Ñ€Ð¾Ñ‚ ÐºÐ°Ð¼ÐµÑ€Ñ‹
            camera.rotation.x += cameraRotationVelocity.x;
            camera.rotation.y += cameraRotationVelocity.y;
            cameraRotationVelocity.x *= damping;
            cameraRotationVelocity.y *= damping;

            // ÐŸÐ»Ð°Ð²Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð¶ÐµÐ½Ð¸Ðµ/Ð¾Ñ‚Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ
            camera.translateZ(cameraZoomVelocity);
            cameraZoomVelocity *= damping;

            // Ð”Ð²Ð¸Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ°Ð¼ÐµÑ€Ñ‹ Ð²Ð¿ÐµÑ€Ñ‘Ð´
            if (isMovingForward) {
                camera.translateZ(-0.1); // ÐœÐµÐ´Ð»ÐµÐ½Ð½Ð¾Ðµ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ðµ Ð²Ð¿ÐµÑ€Ñ‘Ð´
            }

            // ÐžÑ‚Ñ‚Ð°Ð»ÐºÐ¸Ð²Ð°Ð½Ð¸Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² Ð¾Ñ‚ ÐºÐ°Ð¼ÐµÑ€Ñ‹
            repelObjectsFromCamera();

            // ÐÐ½Ð¸Ð¼Ð°Ñ†Ð¸Ñ Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ñ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²
            animateObjects();

            renderer.render(scene, camera);
        }
        
       
        animate();
    </script>
</body>
</html>
