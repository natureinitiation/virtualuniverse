<!DOCTYPE html>
<html lang="ru">
<head>
  <!-- ... (остальные части head остаются без изменений) ... -->
</head>
<body>
  <!-- ... (остальная HTML-структура без изменений) ... -->

  <script>
    // ... (предыдущий код без изменений до функции animate) ...

    function animate() {
      maxOrbitRadius = (canvas.width / 2) - margin;
      const centerX = canvas.width / 2 + offsetX;
      const centerY = canvas.height / 2 + offsetY;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const positions = planets.map((planet, i) => {
        const r = orbitRadius(planet.distance);
        const omega = angularVelocity(planet.period);
        return {
          x: centerX + r * Math.cos(omega * t - Math.PI/2) * scale,
          y: centerY + r * Math.sin(omega * t - Math.PI/2) * scale,
          color: planet.color,
          name: planet.name,
          omega: omega,
          distance: planet.distance
        };
      });
      
      const earthPos = positions[earthIndex];
      
      // Рисование орбит
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      
      planets.forEach((planet, i) => {
        if (!planetVisibility[i]) return;
        const r = orbitRadius(planet.distance) * scale;
        ctx.beginPath();
        if (frame === 'sun') {
          ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        } else {
          // В режиме Earth рисуем орбиты относительно Земли с правильным масштабом
          const relativeDistance = (planet.distance - planets[2].distance);
          const scaledR = orbitRadius(relativeDistance) * scale * 0.8; // Коэффициент для лучшего отображения
          ctx.arc(centerX, centerY, scaledR, 0, Math.PI * 2);
        }
        ctx.stroke();
      });
      
      ctx.setLineDash([]);
      
      // Рисование центрального объекта
      if (frame === 'sun') {
        drawPoint(centerX, centerY, '#ffff00', 6); // Солнце
      } else {
        drawPoint(centerX, centerY, '#008000', 6); // Земля
        // Солнце относительно Земли
        const sunX = centerX - (earthPos.x - centerX);
        const sunY = centerY - (earthPos.y - centerY);
        drawPoint(sunX, sunY, '#ffff00', 6);
      }
      
      // Рисование траекторий и планет
      positions.forEach((pos, i) => {
        if (!planetVisibility[i]) return;
        
        let drawX = pos.x;
        let drawY = pos.y;
        
        if (frame === 'earth') {
          if (i !== 2) { // Для всех планет кроме Земли
            // Вычисляем относительное расстояние с учетом масштаба
            const relativeDistance = (planets[i].distance - planets[2].distance);
            const scaledDistance = orbitRadius(relativeDistance) * scale * 0.8;
            
            // Угловая разница с учетом периодов обращения
            const earthOmega = angularVelocity(planets[2].period);
            const planetOmega = angularVelocity(planets[i].period);
            const angleDiff = (planetOmega - earthOmega) * t;
            
            // Позиция относительно Земли
            drawX = centerX + scaledDistance * Math.cos(angleDiff - Math.PI/2);
            drawY = centerY + scaledDistance * Math.sin(angleDiff - Math.PI/2);
          }
        }
        
        trajectories[i].push({x: drawX, y: drawY});
        if (trajectories[i].length > 300) {
          trajectories[i].shift();
        }
        
        if (trajectories[i].length > 1) {
          ctx.beginPath();
          ctx.strokeStyle = pos.color;
          ctx.lineWidth = 1.5;
          for (let j = 0; j < trajectories[i].length; j++) {
            const p = trajectories[i][j];
            if (j === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
        }
        
        drawPoint(drawX, drawY, pos.color, 3);
      });
      
      ctx.fillStyle = '#fff';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      const infoText = `Days: ${Math.floor(t)} | Scale: ${scale.toFixed(2)}x`;
      ctx.fillText(infoText, canvas.width / 2, 12);
      
      t += dt;
      if (t > 100000) t = 0;
      
      requestAnimationFrame(animate);
    }
    
    animate();
  </script>
</body>
</html>