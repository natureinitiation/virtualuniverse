<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Cube Space</title>
      <link rel="manifest" href="manifest.json">
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; background:rgba(0,0,0,0.5); padding:3px 8px;}
  </style>
</head>
<body>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const SIZE = 5, CELL = 1;
    let voxels = {};
    function setVoxel(x, y, z, val) { voxels[`${x},${y},${z}`] = val; }
    function getVoxel(x, y, z) { return voxels[`${x},${y},${z}`]; }
    function deleteVoxel(x, y, z) { delete voxels[`${x},${y},${z}`]; }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x11111a);

    // Три цветных PointLight
    const lightR = new THREE.PointLight(0xff2222, 2, 100);
    lightR.position.set(10, 0, 0);
    scene.add(lightR);

    const lightG = new THREE.PointLight(0x22ff22, 2, 100);
    lightG.position.set(0, 10, 0);
    scene.add(lightG);

    const lightB = new THREE.PointLight(0x2222ff, 2, 100);
    lightB.position.set(0, 0, 10);
    scene.add(lightB);

    // Можно добавить небольшое общее освещение
    scene.add(new THREE.AmbientLight(0xffffff, 0.15));

    // Камера и рендерер
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(SIZE, SIZE, SIZE);

    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(2,2,2);
    controls.update();

    // Материал: полупрозрачный перламутровый (iridescence)
    function createIridescentMaterial() {
      return new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
        roughness: 0.2,
        metalness: 0.8,
        clearcoat: 0.8,
        clearcoatRoughness: 0.15,
        reflectivity: 1,
        transmission: 0.7, // стеклянность
        thickness: 0.8,
        iridescence: 1,    // перламутровость
        iridescenceIOR: 1.3,
        iridescenceThicknessRange: [100, 400]
      });
    }

    const voxelGroup = new THREE.Group();
    scene.add(voxelGroup);

    setVoxel(2,2,2,true);
    renderVoxels();



    function renderVoxels() {
      while (voxelGroup.children.length) voxelGroup.remove(voxelGroup.children[0]);
      Object.keys(voxels).forEach(key=>{
        const [x,y,z] = key.split(',').map(Number);
        if(getVoxel(x,y,z)) {
          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(CELL * 0.98, CELL * 0.98, CELL * 0.98),
            createIridescentMaterial()
          );
          mesh.position.set(x, y, z);
          voxelGroup.add(mesh);
        }
      });
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

let tapTimeout = null;
let lastTapPos = null;

renderer.domElement.addEventListener('pointerdown', onPointerDown);

function onPointerDown(event) {
  if (event.pointerType === "touch") {
    // Получаем координаты касания
    mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
    mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    let intersects = raycaster.intersectObjects(voxelGroup.children);

    if (intersects.length > 0) {
      let intersect = intersects[0];
      let pos = intersect.object.position.clone();
      let norm = intersect.face.normal.clone();

      // Если это первый тап
      if (!tapTimeout) {
        lastTapPos = {pos, norm};
        tapTimeout = setTimeout(() => {
          // Если не было второго тапа — добавляем (экструдируем)
          let newPos = pos.clone().add(norm);
          if (!getVoxel(newPos.x, newPos.y, newPos.z)) {
            setVoxel(newPos.x, newPos.y, newPos.z, true);
            renderVoxels();
          }
          tapTimeout = null;
          lastTapPos = null;
        }, 300);
      } else {
        // Второй тап (двойной) — удаляем куб
        clearTimeout(tapTimeout);
        tapTimeout = null;
        lastTapPos = null;
        // Не даём удалить последний куб
        if (voxelGroup.children.length > 1) {
          setVoxel(pos.x, pos.y, pos.z, false);
          deleteVoxel(pos.x, pos.y, pos.z);
          renderVoxels();
        }
      }
    }
  } else {
    // Для мыши — старая логика (ЛКМ/ПКМ)
    let extrude = true;
    if (event.button === 2) extrude = false;
    mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
    mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    let intersects = raycaster.intersectObjects(voxelGroup.children);
    if (intersects.length > 0) {
      let intersect = intersects[0];
      let pos = intersect.object.position.clone();
      let norm = intersect.face.normal.clone();
      if (extrude) {
        pos.add(norm);
        if (!getVoxel(pos.x, pos.y, pos.z)) {
          setVoxel(pos.x, pos.y, pos.z, true);
          renderVoxels();
        }
      } else {
        if (voxelGroup.children.length > 1) {
          setVoxel(pos.x, pos.y, pos.z, false);
          deleteVoxel(pos.x, pos.y, pos.z);
          renderVoxels();
        }
      }
    }
  }
}

    renderer.domElement.addEventListener('contextmenu', e=>e.preventDefault());

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
