<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Cube Space</title>
  <link rel="manifest" href="manifest.json">
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; background:rgba(0,0,0,0.5); padding:3px 8px;}
  </style>
</head>
<body>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const SIZE = 5, CELL = 1;
    let voxels = {};
    function setVoxel(x, y, z, val) { voxels[`${x},${y},${z}`] = val; }
    function getVoxel(x, y, z) { return voxels[`${x},${y},${z}`]; }
    function deleteVoxel(x, y, z) { delete voxels[`${x},${y},${z}`]; }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#007bff');

    // --- Свет ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);
    const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 0.8);
    ultramarineLight.position.set(-10, -10, -10);
    scene.add(ultramarineLight);
    const lights = [
        { color: 0xff0000, position: [10, 0, 0] },
        { color: 0x00ff00, position: [0, 10, 0] },
        { color: 0x0000ff, position: [0, 0, 10] },
        { color: 0x3f00ff, position: [-10, -10, -10] },
    ];
    lights.forEach(({ color, position }) => {
        const light = new THREE.DirectionalLight(color, 0.8);
        light.position.set(...position);
        scene.add(light);
    });

    // --- Камера, рендерер, управление ---
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(SIZE, SIZE, SIZE);

    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.005;
    controls.target.set(2,2,2);
    controls.update();

    // --- Перламутровый полупрозрачный материал ---
    function createIridescentMaterial() {
      return new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
        roughness: 0.2,
        metalness: 0.8,
        clearcoat: 0.8,
        clearcoatRoughness: 0.15,
        reflectivity: 1,
        transmission: 0.7,
        thickness: 0.8,
        iridescence: 1,
        iridescenceIOR: 1.3,
        iridescenceThicknessRange: [100, 400]
      });
    }

    const voxelGroup = new THREE.Group();
    scene.add(voxelGroup);

    setVoxel(2,2,2,true);
    renderVoxels();

    function renderVoxels() {
      while (voxelGroup.children.length) voxelGroup.remove(voxelGroup.children[0]);
      Object.keys(voxels).forEach(key=>{
        const [x,y,z] = key.split(',').map(Number);
        if(getVoxel(x,y,z)) {
          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(CELL * 0.98, CELL * 0.98, CELL * 0.98),
            createIridescentMaterial()
          );
          mesh.position.set(x, y, z);
          voxelGroup.add(mesh);
        }
      });
    }

    // --- Одиночный и двойной тап/клик ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let tapTimeout = null;
    let lastTapPos = null;

    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    function onPointerDown(event) {
      if (event.pointerType === "touch") {
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        let intersects = raycaster.intersectObjects(voxelGroup.children);
        if (intersects.length > 0) {
          let intersect = intersects[0];
          let pos = intersect.object.position.clone();
          let norm = intersect.face.normal.clone();
          if (!tapTimeout) {
            lastTapPos = {pos, norm};
            tapTimeout = setTimeout(() => {
              // Одиночный тап: добавить
              let newPos = pos.clone().add(norm);
              if (!getVoxel(newPos.x, newPos.y, newPos.z)) {
                setVoxel(newPos.x, newPos.y, newPos.z, true);
                renderVoxels();
              }
              tapTimeout = null;
              lastTapPos = null;
            }, 300);
          } else {
            // Двойной тап: удалить
            clearTimeout(tapTimeout);
            tapTimeout = null;
            lastTapPos = null;
            if (voxelGroup.children.length > 1) {
              setVoxel(pos.x, pos.y, pos.z, false);
              deleteVoxel(pos.x, pos.y, pos.z);
              renderVoxels();
            }
          }
        }
      } else {
        let extrude = true;
        if (event.button === 2) extrude = false;
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        let intersects = raycaster.intersectObjects(voxelGroup.children);
        if (intersects.length > 0) {
          let intersect = intersects[0];
          let pos = intersect.object.position.clone();
          let norm = intersect.face.normal.clone();
          if (extrude) {
            pos.add(norm);
            if (!getVoxel(pos.x, pos.y, pos.z)) {
              setVoxel(pos.x, pos.y, pos.z, true);
              renderVoxels();
            }
          } else {
            if (voxelGroup.children.length > 1) {
              setVoxel(pos.x, pos.y, pos.z, false);
              deleteVoxel(pos.x, pos.y, pos.z);
              renderVoxels();
            }
          }
        }
      }
    }
    renderer.domElement.addEventListener('contextmenu', e=>e.preventDefault());

    // --- Плавная смена цвета фона ---
    const colors = ['#007bff', '#7058a8', '#000033', '#f48474'];
    let currentColorIndex = 0;
    function changeBackgroundColor() {
        currentColorIndex = (currentColorIndex + 1) % colors.length;
        const targetColor = new THREE.Color(colors[currentColorIndex]);
        animateBackgroundColor(targetColor);
    }
    function animateBackgroundColor(targetColor) {
        const startColor = scene.background.clone();
        const duration = 5; // секунд
        const startTime = performance.now();
        function updateBackgroundColor() {
            const elapsed = (performance.now() - startTime) / 1000;
            const progress = Math.min(elapsed / duration, 1);
            scene.background.lerpColors(startColor, targetColor, progress);
            if (progress < 1) requestAnimationFrame(updateBackgroundColor);
        }
        updateBackgroundColor();
    }
    setInterval(changeBackgroundColor, 100000);

    // --- Анимация ---
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // --- Ресайз ---
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
