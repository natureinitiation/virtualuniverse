<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concurrent Space Polarity</title>
    <link rel="manifest" href="manifest.json">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .button {
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #fff;
            border-radius: 8px;
            font-family: monospace;
            font-size: 18px;
            color: #fff;
            text-align: center;
        }
        .mode-button { top: 10px; left: 20%; transform: translateX(-50%); }
        .go-button { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .vr-only { display: none; }
    </style>
</head>
<body>
    <div class="button mode-button">Static</div>
    <div class="button go-button">Voyage</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webvr-polyfill@0.10.12/build/webvr-polyfill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/vr/WebVR.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x007bff);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 10); // Closer for visibility
        scene.add(camera);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.vr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Debug cube
        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        cube.position.set(0, 1.6, -3);
        scene.add(cube);

        // Controller for VR
        const controller = new THREE.Group();
        controller.position.set(0, 0, -0.5);
        camera.add(controller);
        const raycaster = new THREE.Raycaster();
        const controllerDirection = new THREE.Vector3(0, 0, -1);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);

        // Object storage
        const staticObjects = [];
        const polarObjects = [];
        const maxObjects = 50;

        // Geometry creation
        const createGeometry = (size) => {
            const geometries = [
                new THREE.BoxGeometry(size, size, size),
                new THREE.TetrahedronGeometry(size),
                new THREE.IcosahedronGeometry(size, 0),
                new THREE.OctahedronGeometry(size),
                new THREE.DodecahedronGeometry(size)
            ];
            return geometries[Math.floor(Math.random() * geometries.length)];
        };

        // Object creation
        const createFixObject = (position) => {
            if (staticObjects.length + polarObjects.length >= maxObjects) return;
            const size = Math.random() * 1 + 2;
            const geometry = createGeometry(size);
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                opacity: Math.random() * 0.8 + 0.4,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            mesh.userData = { scatterVelocity: null, scatterStart: null, scatterDuration: 1.0, scatterDeceleration: 0.05 };
            scene.add(mesh);
            staticObjects.push(mesh);
        };

        const createPolarObject = (position) => {
            if (staticObjects.length + polarObjects.length >= maxObjects) return;
            const size = Math.random() * 1 + 2;
            const geometry = createGeometry(size);
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                opacity: Math.random() * 0.5 + 0.5,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData = {
                velocity: new THREE.Vector3(0, 0, 0),
                rotationSpeed: new THREE.Vector3((Math.random() - 0.5) * 0.05, (Math.random() - 0.5) * 0.05, (Math.random() - 0.5) * 0.05),
                mass: Math.random() * 5 + 1,
                polarity: Math.random() < 0.5 ? 1 : -1,
                scatterVelocity: null,
                scatterStart: null,
                scatterDuration: 1.0,
                scatterDeceleration: 0.05
            };
            scene.add(mesh);
            polarObjects.push(mesh);
        };

        // 3D UI for VR
        let mode = 'Fix';
        let isMoving = false;
        const vrUIGroup = new THREE.Group();
        vrUIGroup.position.set(0, 1.6, -2);
        scene.add(vrUIGroup);
        const create3DButton = (text, x, onClick) => {
            const geometry = new THREE.PlaneGeometry(1, 0.4);
            const material = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.8 });
            const button = new THREE.Mesh(geometry, material);
            button.position.set(x, 0, 0);
            button.userData = { clickable: true, onClick };
            vrUIGroup.add(button);
            // Text as geometry (fallback, no FontLoader)
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = '40px monospace';
            ctx.fillText(text, 10, 50);
            const texture = new THREE.CanvasTexture(canvas);
            const textMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 0.2),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true })
            );
            textMesh.position.set(x - 0.4, -0.1, 0.01);
            vrUIGroup.add(textMesh);
            return { button, textMesh };
        };
        let modeButtonVR, goButtonVR;
        const updateVRButtons = () => {
            if (modeButtonVR) {
                vrUIGroup.remove(modeButtonVR.textMesh);
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.font = '40px monospace';
                ctx.fillText(mode === 'Fix' ? 'Статич' : mode === 'Polar' ? 'Динамика' : 'Удалить', 10, 50);
                const texture = new THREE.CanvasTexture(canvas);
                modeButtonVR.textMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 0.2),
                    new THREE.MeshBasicMaterial({ map: texture, transparent: true })
                );
                modeButtonVR.textMesh.position.set(-1.4, -0.1, 0.01);
                vrUIGroup.add(modeButtonVR.textMesh);
            }
            if (goButtonVR) {
                vrUIGroup.remove(goButtonVR.textMesh);
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.font = '40px monospace';
                ctx.fillText(isMoving ? 'Стоп' : 'Идти', 10, 50);
                const texture = new THREE.CanvasTexture(canvas);
                goButtonVR.textMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 0.2),
                    new THREE.MeshBasicMaterial({ map: texture, transparent: true })
                );
                goButtonVR.textMesh.position.set(0.6, -0.1, 0.01);
                vrUIGroup.add(goButtonVR.textMesh);
            }
        };
        modeButtonVR = create3DButton('Статич', -1, () => {
            mode = mode === 'Fix' ? 'Polar' : mode === 'Polar' ? 'Delete' : 'Fix';
            document.querySelector('.mode-button').innerText = mode === 'Fix' ? 'Static' : mode === 'Polar' ? 'Dynamic' : 'Delete';
            updateVRButtons();
        });
        goButtonVR = create3DButton('Идти', 1, () => {
            isMoving = !isMoving;
            document.querySelector('.go-button').innerText = isMoving ? 'Stop' : 'Voyage';
            if (isMoving) adjustCameraFocus();
            else targetVelocity.set(0, 0, 0);
            updateVRButtons();
        });

        // HTML UI for PC
        const modeButton = document.querySelector('.mode-button');
        modeButton.addEventListener('click', () => {
            mode = mode === 'Fix' ? 'Polar' : mode === 'Polar' ? 'Delete' : 'Fix';
            modeButton.innerText = mode === 'Fix' ? 'Static' : mode === 'Polar' ? 'Dynamic' : 'Delete';
            updateVRButtons();
        });
        const goButton = document.querySelector('.go-button');
        goButton.addEventListener('click', () => {
            isMoving = !isMoving;
            goButton.innerText = isMoving ? 'Stop' : 'Voyage';
            if (isMoving) adjustCameraFocus();
            else targetVelocity.set(0, 0, 0);
            updateVRButtons();
        });

        // Interactions
        let targetVelocity = new THREE.Vector3();
        const cameraVelocity = new THREE.Vector3();
        const handleInteraction = (isVR, clientX, clientY, triggerPressed) => {
            let position;
            if (isVR) {
                raycaster.set(controller.getWorldPosition(new THREE.Vector3()), controller.getWorldDirection(controllerDirection));
            } else {
                const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
                raycaster.setFromCamera(mouse, camera);
            }
            const intersects = raycaster.intersectObjects([...staticObjects, ...polarObjects, ...vrUIGroup.children.filter(o => o.userData.clickable)]);
            if (triggerPressed) {
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (obj.userData.clickable) {
                        obj.onClick();
                    } else if (mode === 'Delete') {
                        scene.remove(obj);
                        staticObjects.splice(staticObjects.indexOf(obj), 1);
                        polarObjects.splice(polarObjects.indexOf(obj), 1);
                    } else {
                        const direction = new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2).normalize();
                        obj.userData.scatterVelocity = direction.multiplyScalar(15 + Math.random() * 10);
                        obj.userData.scatterStart = performance.now();
                    }
                } else if (mode === 'Fix' || mode === 'Polar') {
                    position = isVR
                        ? camera.position.clone().add(controller.getWorldDirection(new THREE.Vector3()).multiplyScalar(-10))
                        : camera.position.clone().add(raycaster.ray.direction.multiplyScalar(10));
                    if (mode === 'Fix') createFixObject(position);
                    else createPolarObject(position);
                }
            }
        };

        // PC input
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('button')) return;
            handleInteraction(false, e.clientX, e.clientY, true);
        });

        // VR input
        let isVRActive = false;
        navigator.getVRDisplays().then(displays => {
            if (displays.length > 0) {
                const vrDisplay = displays[0];
                renderer.vr.setDevice(vrDisplay);
                function checkGamepads() {
                    vrDisplay.getGamepads().forEach(gamepad => {
                        if (gamepad && gamepad.buttons[0].pressed) {
                            handleInteraction(true, 0, 0, true);
                        }
                    });
                    if (vrDisplay.isPresenting) requestAnimationFrame(checkGamepads);
                }
                window.addEventListener('vrdisplaypresentchange', () => {
                    isVRActive = vrDisplay.isPresenting;
                    document.querySelectorAll('.button').forEach(btn => {
                        btn.style.display = isVRActive ? 'none' : 'block';
                    });
                    if (isVRActive) {
                        checkGamepads();
                        renderer.setAnimationLoop(() => {
                            updateScene();
                            renderer.render(scene, camera);
                        });
                    } else {
                        renderer.setAnimationLoop(null);
                        animate();
                    }
                });
            }
        });

        // Camera movement
        const adjustCameraFocus = () => {
            const direction = isVRActive
                ? controller.getWorldDirection(new THREE.Vector3()).multiplyScalar(-1)
                : new THREE.Vector3(0, 0, -1);
            const azimuthOffset = (Math.random() - 0.5) * THREE.MathUtils.degToRad(20);
            const elevationOffset = (Math.random() - 0.5) * THREE.MathUtils.degToRad(20);
            direction.applyQuaternion(new THREE.Quaternion()
                .setFromAxisAngle(new THREE.Vector3(0, 1, 0), azimuthOffset)
                .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), elevationOffset)));
            targetVelocity.copy(direction);
        };

        // Physics
        const applyCameraRepulsion = () => {
            const repulsionDistance = 15;
            const repulsionStrength = 0.05;
            [...staticObjects, ...polarObjects].forEach(obj => {
                const distance = camera.position.distanceTo(obj.position);
                if (distance < repulsionDistance) {
                    const direction = obj.position.clone().sub(camera.position).normalize();
                    const force = direction.multiplyScalar((repulsionDistance - distance) * repulsionStrength);
                    if (obj.userData.velocity) {
                        obj.userData.velocity.add(force);
                    } else if (!obj.userData.scatterVelocity) {
                        obj.position.add(force);
                    }
                }
            });
        };

        const handlePolarInteractions = () => {
            for (let i = 0; i < polarObjects.length; i++) {
                for (let j = i + 1; j < polarObjects.length; j++) {
                    const objA = polarObjects[i];
                    const objB = polarObjects[j];
                    const distance = objA.position.distanceTo(objB.position);
                    if (distance < 1) {
                        const direction = objB.position.clone().sub(objA.position).normalize();
                        const polarityEffect = objA.userData.polarity * objB.userData.polarity;
                        const force = direction.multiplyScalar(polarityEffect * 0.05);
                        objA.userData.velocity.add(force.clone().multiplyScalar(-1 / objA.userData.mass));
                        objB.userData.velocity.add(force.clone().multiplyScalar(1 / objB.userData.mass));
                    }
                }
            }
        };

        const handlePolarAndStaticInteractions = () => {
            polarObjects.forEach(polarObj => {
                staticObjects.forEach(staticObj => {
                    const distance = polarObj.position.distanceTo(staticObj.position);
                    if (distance < 15) {
                        const direction = staticObj.position.clone().sub(polarObj.position).normalize();
                        const repulsionForce = direction.multiplyScalar(0.005 * (8 - distance));
                        if (!staticObj.userData.scatterVelocity) {
                            staticObj.position.add(repulsionForce);
                        }
                        polarObj.userData.velocity.add(repulsionForce.clone().multiplyScalar(-1 / polarObj.userData.mass));
                    }
                });
            });
        };

        const applyDeceleration = () => {
            polarObjects.forEach(obj => {
                if (obj.userData.scatterVelocity) return;
                if (obj.userData.velocity.length() > 0) {
                    obj.userData.velocity.multiplyScalar(0.997);
                    if (obj.userData.velocity.length() < 0.001) {
                        obj.userData.velocity.set(0, 0, 0);
                    }
                }
            });
        };

        // Scene update
        const updateScene = () => {
            if (isMoving) cameraVelocity.lerp(targetVelocity, 0.001);
            else cameraVelocity.lerp(new THREE.Vector3(), 0.01);
            camera.position.add(cameraVelocity);
            applyCameraRepulsion();
            polarObjects.forEach(obj => {
                if (obj.userData.scatterVelocity) {
                    const elapsed = (performance.now() - obj.userData.scatterStart) / 1000;
                    if (elapsed < obj.userData.scatterDuration) {
                        obj.position.add(obj.userData.scatterVelocity.clone().multiplyScalar(1 / 60));
                    } else {
                        obj.userData.scatterVelocity.multiplyScalar(0.95);
                        if (obj.userData.scatterVelocity.length() < 0.01) {
                            obj.userData.scatterVelocity = null;
                            obj.userData.scatterStart = null;
                        } else {
                            obj.position.add(obj.userData.scatterVelocity.clone().multiplyScalar(1 / 60));
                        }
                    }
                }
                obj.position.add(obj.userData.velocity);
                obj.rotation.x += obj.userData.rotationSpeed.x;
                obj.rotation.y += obj.userData.rotationSpeed.y;
                obj.rotation.z += obj.userData.rotationSpeed.z;
            });
            staticObjects.forEach(obj => {
                if (obj.userData.scatterVelocity) {
                    const elapsed = (performance.now() - obj.userData.scatterStart) / 1000;
                    if (elapsed < obj.userData.scatterDuration) {
                        obj.position.add(obj.userData.scatterVelocity.clone().multiplyScalar(1 / 60));
                    } else {
                        obj.userData.scatterVelocity.multiplyScalar(0.95);
                        if (obj.userData.scatterVelocity.length() < 0.01) {
                            obj.userData.scatterVelocity = null;
                            obj.userData.scatterStart = null;
                        } else {
                            obj.position.add(obj.userData.scatterVelocity.clone().multiplyScalar(1 / 60));
                        }
                    }
                }
            });
            if (mode === 'Polar') handlePolarInteractions();
            handlePolarAndStaticInteractions();
            applyDeceleration();
        };

        // Animation loop
        const animate = () => {
            if (!isVRActive) {
                requestAnimationFrame(animate);
                updateScene();
                renderer.render(scene, camera);
            }
        };

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
