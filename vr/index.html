<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>VR Scene for Oculus Go</title>
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <style>
    /* Центрирование кнопки Enter VR */
    .a-enter-vr-button {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      z-index: 9999 !important;
      background-color: #333 !important;
      padding: 10px !important;
      border-radius: 5px !important;
    }
    /* Стили для секретов */
    .secret {
      position: fixed;
      transform: translate(-50%, -50%);
      font-family: monospace;
      font-size: 18px;
      color: white;
      text-decoration: none;
      padding: 10px;
      border-radius: 8px;
      pointer-events: auto;
      z-index: 1000;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
  </style>
</head>
<body>
  <a-scene vr-mode-ui="enabled: true" physics-manager>
    <!-- Небо как фон -->
    <a-sky color="#87CEEB"></a-sky>

    <!-- Начальный статический объект -->
    <a-entity
      geometry="primitive: box; size: 1"
      material="color: #FF6347; roughness: 0.5; metalness: 0.5; opacity: 0.8; transparent: true"
      position="0 1.5 -3"
      rotation="0 45 0"
      static-object>
    </a-entity>

    <!-- Начальный динамический объект -->
    <a-entity
      geometry="primitive: sphere; radius: 0.5"
      material="color: #FFD700; roughness: 0.5; metalness: 0.5; opacity: 0.8; transparent: true"
      position="2 1 -4"
      polar-object="rotationSpeed: 0.02 0.02 0.02; mass: 2; polarity: 1">
    </a-entity>

    <!-- Освещение -->
    <a-light type="ambient" color="#FFF" intensity="0.5"></a-light>
    <a-light type="directional" color="#FFF" intensity="0.5" position="1 1 1"></a-light>

    <!-- Камера с контроллером -->
    <a-camera position="0 1.6 0">
      <a-entity id="controller" oculus-go-controls="hand: right"></a-entity>
    </a-camera>
  </a-scene>

  <script>
    // Логи для отладки
    document.addEventListener('DOMContentLoaded', () => {
      const scene = document.querySelector('a-scene');
      scene.addEventListener('loaded', () => {
        console.log('Scene loaded');
      });
      scene.addEventListener('enter-vr', () => {
        console.log('Entered VR mode');
      });
      const vrButton = document.querySelector('.a-enter-vr-button');
      if (vrButton) {
        vrButton.addEventListener('click', () => {
          console.log('Enter VR button clicked');
        });
      }
    });

    // Глобальные переменные
    const staticObjects = [];
    const polarObjects = [];
    const activePoints = [];
    const secrets = ['focus', 'try', 'switch', 'scroll', 'scale', 'shift', 'move', 'tap', 'touch', 'click', 'right', 'button', 'mouse', 'screen', 'fly', 'double', 'follow', 'read', 'peer', 'rest', 'quick', 'hold', 'and', 'or', 'virtual', 'eternity'];
    const mode = 'Fix'; // Фиксированный режим для теста

    // Компонент для статических объектов
    AFRAME.registerComponent('static-object', {
      schema: {
        scatterVelocity: { type: 'vec3', default: null },
        scatterStart: { type: 'float', default: null },
        scatterDuration: { type: 'float', default: 1.0 },
        scatterDeceleration: { type: 'float', default: 0.05 }
      },
      init: function () {
        this.el.setAttribute('data-clickable', '');
        this.el.addEventListener('click', () => this.scatter());
        staticObjects.push(this.el);
        console.log('Static object initialized:', this.el);
      },
      tick: function (time, delta) {
        const deltaS = delta / 1000;
        const obj = this.el.object3D;

        if (this.data.scatterVelocity) {
          const elapsed = (time - this.data.scatterStart) / 1000;
          const sv = new THREE.Vector3().copy(this.data.scatterVelocity);
          if (elapsed < this.data.scatterDuration) {
            obj.position.add(sv.multiplyScalar(deltaS));
          } else {
            sv.multiplyScalar(1 - this.data.scatterDeceleration);
            if (sv.length() < 0.01) {
              this.data.scatterVelocity = null;
              this.data.scatterStart = null;
            } else {
              obj.position.add(sv.multiplyScalar(deltaS));
              this.data.scatterVelocity = sv;
            }
          }
        }
      },
      scatter: function () {
        console.log('Scattering static object:', this.el);
        const direction = new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2).normalize();
        const speed = 15 + Math.random() * 10;
        this.data.scatterVelocity = direction.multiplyScalar(speed);
        this.data.scatterStart = performance.now();
        this.el.object3D.rotation.x += Math.random() * 0.5;
        this.el.object3D.rotation.y += Math.random() * 0.5;
        this.el.object3D.rotation.z += Math.random() * 0.5;

        if (Math.random() < 0.3) {
          const pos = this.el.object3D.position.clone();
          const pos2D = pos.project(this.el.sceneEl.camera);
          const wordX = (pos2D.x * 0.5 + 0.5) * window.innerWidth;
          const wordY = (-pos2D.y * 0.5 + 0.5) * window.innerHeight;
          createSecret(wordX, wordY);
        }
      }
    });

    // Компонент для динамических объектов
    AFRAME.registerComponent('polar-object', {
      schema: {
        velocity: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
        rotationSpeed: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
        mass: { type: 'float', default: 1 },
        polarity: { type: 'int', default: 1 },
        scatterVelocity: { type: 'vec3', default: null },
        scatterStart: { type: 'float', default: null },
        scatterDuration: { type: 'float', default: 1.0 },
        scatterDeceleration: { type: 'float', default: 0.05 }
      },
      init: function () {
        this.el.setAttribute('data-clickable', '');
        this.el.addEventListener('click', () => this.scatter());
        polar

Objects.push(this.el);
        console.log('Polar object initialized:', this.el);
      },
      tick: function (time, delta) {
        const deltaS = delta / 1000;
        const obj = this.el.object3D;

        if (this.data.scatterVelocity) {
          const elapsed = (time - this.data.scatterStart) / 1000;
          const sv = new THREE.Vector3().copy(this.data.scatterVelocity);
          if (elapsed < this.data.scatterDuration) {
            obj.position.add(sv.multiplyScalar(deltaS));
          } else {
            sv.multiplyScalar(1 - this.data.scatterDeceleration);
            if (sv.length() < 0.01) {
              this.data.scatterVelocity = null;
              this.data.scatterStart = null;
            } else {
              obj.position.add(sv.multiplyScalar(deltaS));
              this.data.scatterVelocity = sv;
            }
          }
        }

        obj.position.add(new THREE.Vector3().copy(this.data.velocity).multiplyScalar(deltaS));
        obj.rotation.x += this.data.rotationSpeed.x * deltaS;
        obj.rotation.y += this.data.rotationSpeed.y * deltaS;
        obj.rotation.z += this.data.rotationSpeed.z * deltaS;
      },
      scatter: function () {
        console.log('Scattering polar object:', this.el);
        const direction = new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2).normalize();
        const speed = 15 + Math.random() * 10;
        this.data.scatterVelocity = direction.multiplyScalar(speed);
        this.data.scatterStart = performance.now();
        this.el.object3D.rotation.x += Math.random() * 0.5;
        this.el.object3D.rotation.y += Math.random() * 0.5;
        this.el.object3D.rotation.z += Math.random() * 0.5;

        if (Math.random() < 0.3) {
          const pos = this.el.object3D.position.clone();
          const pos2D = pos.project(this.el.sceneEl.camera);
          const wordX = (pos2D.x * 0.5 + 0.5) * window.innerWidth;
          const wordY = (-pos2D.y * 0.5 + 0.5) * window.innerHeight;
          createSecret(wordX, wordY);
        }
      }
    });

    // Компонент для управления физикой
    AFRAME.registerComponent('physics-manager', {
      tick: function () {
        applyCameraRepulsion();
        if (mode === 'Polar') handlePolarInteractions();
        handlePolarAndStaticInteractions();
        applyDeceleration();
      }
    });

    // Функции физики
    function applyCameraRepulsion() {
      const repulsionDistance = 15;
      const repulsionStrength = 0.05;
      const cameraPos = document.querySelector('a-camera').object3D.position;
      [...staticObjects, ...polarObjects].forEach((el) => {
        const objPos = el.object3D.position;
        const distance = cameraPos.distanceTo(objPos);
        if (distance < repulsionDistance) {
          const direction = objPos.clone().sub(cameraPos).normalize();
          const force = direction.multiplyScalar((repulsionDistance - distance) * repulsionStrength);
          if (el.components['polar-object']) {
            el.components['polar-object'].data.velocity.add(force);
          } else if (!el.components['static-object'].data.scatterVelocity) {
            objPos.add(force);
          }
        }
      });
    }

    function handlePolarInteractions() {
      for (let i = 0; i < polarObjects.length; i++) {
        for (let j = i + 1; j < polarObjects.length; j++) {
          const objA = polarObjects[i].object3D;
          const objB = polarObjects[j].object3D;
          const distance = objA.position.distanceTo(objB.position);
          if (distance < 1) {
            const direction = objB.position.clone().sub(objA.position).normalize();
            const polarityEffect = polarObjects[i].components['polar-object'].data.polarity * polarObjects[j].components['polar-object'].data.polarity;
            const force = direction.multiplyScalar(polarityEffect * 0.05);
            polarObjects[i].components['polar-object'].data.velocity.add(force.clone().multiplyScalar(-1 / polarObjects[i].components['polar-object'].data.mass));
            polarObjects[j].components['polar-object'].data.velocity.add(force.clone().multiplyScalar(1 / polarObjects[j].components['polar-object'].data.mass));
          }
        }
      }
    }

    function handlePolarAndStaticInteractions() {
      polarObjects.forEach((polarEl) => {
        staticObjects.forEach((staticEl) => {
          const polarPos = polarEl.object3D.position;
          const staticPos = staticEl.object3D.position;
          const distance = polarPos.distanceTo(staticPos);
          if (distance < 15) {
            const direction = staticPos.clone().sub(polarPos).normalize();
            const repulsionForce = direction.multiplyScalar(0.005 * (8 - distance));
            if (!staticEl.components['static-object'].data.scatterVelocity) {
              staticPos.add(repulsionForce);
            }
            polarEl.components['polar-object'].data.velocity.add(repulsionForce.clone().multiplyScalar(-1 / polarEl.components['polar-object'].data.mass));
          }
        });
      });
    }

    function applyDeceleration() {
      polarObjects.forEach((el) => {
        const comp = el.components['polar-object'];
        if (comp.data.scatterVelocity) return;
        const vel = new THREE.Vector3().copy(comp.data.velocity);
        if (vel.length() > 0) {
          vel.multiplyScalar(1 - 0.003);
          if (vel.length() < 0.001) {
            comp.data.velocity.set(0, 0, 0);
          } else {
            comp.data.velocity.copy(vel);
          }
        }
      });
    }

    // Создание объектов
    function createGeometry() {
      const geometries = ['box', 'tetrahedron', 'icosahedron', 'octahedron', 'dodecahedron'];
      return geometries[Math.floor(Math.random() * geometries.length)];
    }

    function createFixObject() {
      console.log('Attempting to create static object');
      const size = Math.random() * 1 + 2;
      const geometry = createGeometry();
      const entity = document.createElement('a-entity');
      entity.setAttribute('geometry', `primitive: ${geometry}; size: ${size}`);
      entity.setAttribute('material', {
        color: `#${Math.floor(Math.random() * 16777215).toString(16)}`,
        roughness: 0.5,
        metalness: 0.5,
        opacity: 0.8,
        transparent: true
      });
      const camera = document.querySelector('a-camera').object3D;
      const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const position = camera.position.clone().add(direction.multiplyScalar(3));
      entity.setAttribute('position', position);
      entity.setAttribute('rotation', {
        x: Math.random() * 360,
        y: Math.random() * 360,
        z: Math.random() * 360
      });
      entity.setAttribute('static-object', '');
      entity.setAttribute('data-clickable', '');
      document.querySelector('a-scene').appendChild(entity);
      console.log('Created static object at:', position);
    }

    function createPolarObject() {
      console.log('Attempting to create polar object');
      const size = Math.random() * 1 + 2;
      const geometry = createGeometry();
      const entity = document.createElement('a-entity');
      entity.setAttribute('geometry', `primitive: ${geometry}; size: ${size}`);
      entity.setAttribute('material', {
        color: `#${Math.floor(Math.random() * 16777215).toString(16)}`,
        roughness: 0.5,
        metalness: 0.5,
        opacity: 0.8,
        transparent: true
      });
      const camera = document.querySelector('a-camera').object3D;
      const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const position = camera.position.clone().add(direction.multiplyScalar(3));
      entity.setAttribute('position', position);
      entity.setAttribute('polar-object', {
        rotationSpeed: {
          x: (Math.random() - 0.5) * 0.05,
          y: (Math.random() - 0.5) * 0.05,
          z: (Math.random() - 0.5) * 0.05
        },
        mass: Math.random() * 5 + 1,
        polarity: Math.random() < 0.5 ? 1 : -1
      });
      entity.setAttribute('data-clickable', '');
      document.querySelector('a-scene').appendChild(entity);
      console.log('Created polar object at:', position);
    }

    // Создание "секретов"
    function createSecret(x, y) {
      console.log('Creating secret at:', x, y);
      const secret = document.createElement('a');
      secret.className = 'secret';
      const word = secrets[Math.floor(Math.random() * secrets.length)];
      secret.textContent = word;
      secret.style.cssText = `
        position: fixed; left: ${x}px; top: ${y}px; transform: translate(-50%, -50%); opacity: 0;
        font-family: monospace; font-size: 18px; color: white; text-decoration: none;
        padding: 10px; border-radius: 8px; pointer-events: auto; z-index: 1000;
      `;
      document.body.appendChild(secret);

      const rect = secret.getBoundingClientRect();
      const minWordDistance = Math.max(rect.width, rect.height) + 20;
      if (isWordOccupied(x, y, minWordDistance)) {
        secret.remove();
        console.log('Secret removed due to overlap');
        return;
      }

      activePoints.push({ x, y, timestamp: Date.now(), isWord: true });

      setTimeout(() => {
        secret.style.opacity = 1;
        secret.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 10);

      setTimeout(() => {
        secret.style.opacity = 0;
        secret.style.transform = 'translate(-50%, -50%) scale(0.8)';
      }, 8000);

      setTimeout(() => {
        secret.remove();
        const index = activePoints.findIndex(p => p.x === x && p.y === y && p.isWord);
        if (index !== -1) activePoints.splice(index, 1);
        console.log('Secret removed');
      }, 8500);
    }

    function isWordOccupied(x, y, minDistance) {
      return activePoints.some(point => {
        if (!point.isWord) return false;
        const dx = point.x - x;
        const dy = point.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < minDistance;
      });
    }

    // Обработка триггера
    const controller = document.querySelector('#controller');
    controller.addEventListener('triggerdown', () => {
      console.log('Trigger down detected');
      createFixObject();
    });
    controller.addEventListener('triggerpressed', () => {
      console.log('Trigger pressed detected');
      createFixObject();
    });
  </script>
</body>
</html>
