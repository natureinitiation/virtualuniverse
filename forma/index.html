<!DOCTYPE html>
<html>
<head>
    <title>Полный 3D-Редактор: Исправлено Удаление Сторон</title>
    <style>
        /* Предотвращение выделения текста и лишних действий браузера */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #222;
            -webkit-user-select: none; 
            -moz-user-select: none;    
            -ms-user-select: none;     
            user-select: none;         
        }
        canvas { 
            touch-action: none; 
            width: 100vw; 
            height: 100vh; 
        } 
    </style>
</head>
<body>

    <canvas id="cubeCanvas"></canvas> 

    <script>
        const canvas = document.getElementById('cubeCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height, center = {};
        let angleX = 0.8, angleY = 1.0; 
        const A = 100; 
        
        // --- Управление жестами ---
        let pointers = {}; 
        let lastScale = 1;
        let scaleFactor = 1.0;
        let offsetX = 0; 
        let offsetY = 0; 
        
        // Переменные для Long Press (Экструзия)
        let pressTimer = null;
        let isLongPress = false;
        let selectedFaceIndexForExtrusion = -1;
        const LONG_PRESS_THRESHOLD = 500; 
        
        // Переменные для Double Tap (Удаление)
        let lastTapTime = 0;
        let lastTappedFaceIndex = -1;
        const DOUBLE_TAP_TIME = 300; 
        const MOVE_THRESHOLD = 5; 
        
        let geometry = createCube(A);

        // --- ГЕОМЕТРИЯ ---
        
        function createCube(a) {
            const vertices = [
                [-a, -a, -a], [ a, -a, -a], [ a,  a, -a], [-a,  a, -a], 
                [-a, -a,  a], [ a, -a,  a], [ a,  a,  a], [-a,  a,  a]  
            ];
            const faces = [
                { indices: [0, 1, 2, 3], color: '#3333aa' },
                { indices: [4, 5, 6, 7], color: '#33aa33' },
                { indices: [1, 5, 6, 2], color: '#aa3333' },
                { indices: [0, 4, 7, 3], color: '#aaaa33' },
                { indices: [3, 7, 6, 2], color: '#33aaaa' },
                { indices: [0, 4, 5, 1], color: '#aa33aa' }
            ];
            return { vertices, faces };
        }
        
        // --- МАТЕМАТИКА 3D ---
        
        function rotateX(point, angle) {
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x, y * cos - z * sin, z * cos + y * sin];
        }

        function rotateY(point, angle) {
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x * cos + z * sin, y, z * cos - x * sin];
        }

        function project(point) {
            const fov = 500; 
            const scale = fov / (fov + point[2]); 
            return [
                (point[0]) * scale * scaleFactor + center.x + offsetX, 
                (point[1]) * scale * scaleFactor + center.y + offsetY
            ];
        }
        
        function getFaceNormal(p1, p2, p3) {
            const v1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            const v2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];
            
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]
            ];
        }

        // --- ФУНКЦИИ РЕДАКТИРОВАНИЯ ---
        
        function extrudeFace(faceIndex) {
            const face = geometry.faces[faceIndex];
            const oldVerticesIndices = face.indices;
            
            const nP1 = geometry.vertices[oldVerticesIndices[0]];
            const nP2 = geometry.vertices[oldVerticesIndices[1]];
            const nP3 = geometry.vertices[oldVerticesIndices[2]];
            const normal = getFaceNormal(nP1, nP2, nP3);
            
            const length = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2);
            const unitNormal = [normal[0] / length, normal[1] / length, normal[2] / length];

            const newVertices = [];
            for (const vIndex of oldVerticesIndices) {
                const oldV = geometry.vertices[vIndex];
                const newV = [
                    oldV[0] + unitNormal[0] * A,
                    oldV[1] + unitNormal[1] * A,
                    oldV[2] + unitNormal[2] * A
                ];
                newVertices.push(newV);
            }

            const newVerticesStartIdx = geometry.vertices.length;
            geometry.vertices.push(...newVertices);

            const newFace = {
                indices: [newVerticesStartIdx, newVerticesStartIdx + 1, newVerticesStartIdx + 2, newVerticesStartIdx + 3],
                color: face.color 
            };
            geometry.faces.push(newFace);

            const connectingFaces = [
                { indices: [oldVerticesIndices[0], oldVerticesIndices[1], newVerticesStartIdx + 1, newVerticesStartIdx + 0], color: face.color },
                { indices: [oldVerticesIndices[1], oldVerticesIndices[2], newVerticesStartIdx + 2, newVerticesStartIdx + 1], color: face.color },
                { indices: [oldVerticesIndices[2], oldVerticesIndices[3], newVerticesStartIdx + 3, newVerticesStartIdx + 2], color: face.color },
                { indices: [oldVerticesIndices[3], oldVerticesIndices[0], newVerticesStartIdx + 0, newVerticesStartIdx + 3], color: face.color },
            ];
            geometry.faces.push(...connectingFaces);
            
            // Удаляем исходную грань
            geometry.faces.splice(faceIndex, 1);
        }

        // ПЕРЕСМОТРЕННАЯ ФУНКЦИЯ УДАЛЕНИЯ: Удаляет грань по индексу
        function removeFaceByIndex(faceIndex) {
             if (faceIndex !== -1 && faceIndex < geometry.faces.length) {
                geometry.faces.splice(faceIndex, 1);
                // В реальном 3D-редакторе здесь нужно было бы перестроить меш,
                // но для абстрактного примера мы просто удаляем грань.
             }
        }
        
        // --- СЛУЖЕБНЫЕ ФУНКЦИИ ---
        
        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            center = { x: width / 2, y: height / 2 };
        }

        let projectedFacesData = []; 

        function drawCube() {
            ctx.clearRect(0, 0, width, height); 
            
            const transformedVertices = [];
            for (const vertex of geometry.vertices) {
                let p = [...vertex]; 
                p = rotateX(p, angleX);
                p = rotateY(p, angleY);
                transformedVertices.push(p);
            }
            
            projectedFacesData = [];

            for (let i = 0; i < geometry.faces.length; i++) {
                const face = geometry.faces[i];
                const vIndices = face.indices;
                
                if (vIndices.length < 3) continue;

                const p1 = transformedVertices[vIndices[0]];
                const p2 = transformedVertices[vIndices[1]];
                const p3 = transformedVertices[vIndices[2]];
                
                const projectedCoords = vIndices.map(idx => project(transformedVertices[idx]));

                projectedFacesData.push({
                    index: i,
                    coords: projectedCoords,
                    color: face.color,
                    depth: (p1[2] + p2[2] + p3[2] + (vIndices.length > 3 ? transformedVertices[vIndices[3]][2] : p3[2])) / vIndices.length 
                });
            }
            
            projectedFacesData.sort((a, b) => b.depth - a.depth); 

            for (const faceData of projectedFacesData) {
                ctx.fillStyle = faceData.color;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(faceData.coords[0][0], faceData.coords[0][1]);
                for (let j = 1; j < faceData.coords.length; j++) {
                    ctx.lineTo(faceData.coords[j][0], faceData.coords[j][1]);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            requestAnimationFrame(drawCube);
        }

        // --- ЛОГИКА УПРАВЛЕНИЯ ЖЕСТАМИ ---
        
        function getCanvasPosition(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function isPointInPolygon(point, polygon) {
            let x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i][0], yi = polygon[i][1];
                let xj = polygon[j][0], yj = polygon[j][1];
                
                let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getFaceIndexAtPoint(pos) {
            for (let i = projectedFacesData.length - 1; i >= 0; i--) { 
                const faceData = projectedFacesData[i];
                if (isPointInPolygon(pos, faceData.coords)) {
                    return faceData.index;
                }
            }
            return -1;
        }

        // --- Multitouch Helpers ---
        
        function getPointerCenter() {
            const keys = Object.keys(pointers);
            if (keys.length < 2) return null;
            
            const p1 = pointers[keys[0]];
            const p2 = pointers[keys[1]];
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function getPointerDistance() {
            const keys = Object.keys(pointers);
            if (keys.length < 2) return 0;
            
            const p1 = pointers[keys[0]];
            const p2 = pointers[keys[1]];
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }
        
        // --- Обработчики событий ---

        canvas.addEventListener('pointerdown', (e) => {
            const canvasPos = getCanvasPosition(e);
            const faceIndex = getFaceIndexAtPoint(canvasPos);
            
            pointers[e.pointerId] = { 
                x: e.clientX, 
                y: e.clientY, 
                startX: e.clientX, 
                startY: e.clientY,
                faceIndex: faceIndex 
            };
            
            const pointerCount = Object.keys(pointers).length;
            
            if (pointerCount === 1) {
                // --- Long Press (Экструзия) ---
                isLongPress = false;
                selectedFaceIndexForExtrusion = faceIndex;
                
                if (faceIndex !== -1) {
                    clearTimeout(pressTimer);
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                    }, LONG_PRESS_THRESHOLD);
                }
                
                // --- Double Tap (Удаление) ---
                const now = Date.now();
                // Проверяем, что это Double Tap и что он произошел на той же грани
                const isDoubleTap = (now - lastTapTime < DOUBLE_TAP_TIME) && (faceIndex === lastTappedFaceIndex) && (faceIndex !== -1);

                if (isDoubleTap) {
                    // Удаление произойдет в pointerup, если не было сдвига
                    // ВАЖНО: Мы не вызываем removeFace здесь! Мы ждём up.
                    // Обнуляем время, чтобы не вызвать тройной тап
                    lastTapTime = 0; 
                } else {
                    lastTapTime = now;
                    lastTappedFaceIndex = faceIndex;
                }

            } else if (pointerCount === 2) {
                // --- Pan/Zoom (Два пальца) ---
                clearTimeout(pressTimer);
                isLongPress = false;
                lastScale = getPointerDistance();
                
                lastTapTime = 0; // Сброс Double Tap при мультитаче
                lastTappedFaceIndex = -1;
            }
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!pointers[e.pointerId]) return;

            const oldX = pointers[e.pointerId].x;
            const oldY = pointers[e.pointerId].y;

            pointers[e.pointerId].x = e.clientX;
            pointers[e.pointerId].y = e.clientY;

            const pointerCount = Object.keys(pointers).length;
            
            if (pointerCount === 1) {
                // --- ВРАЩЕНИЕ СЦЕНЫ (Single touch) ---
                
                const dx = e.clientX - oldX;
                const dy = e.clientY - oldY;

                // Если палец сдвинулся, отменяем Long Press и Double Tap-логику
                if (pressTimer && (Math.abs(e.clientX - pointers[e.pointerId].startX) > MOVE_THRESHOLD || Math.abs(e.clientY - pointers[e.pointerId].startY) > MOVE_THRESHOLD)) {
                    clearTimeout(pressTimer);
                    isLongPress = false;
                    // Сброс lastTapTime теперь происходит в pointerup
                }
                
                angleY += dx * 0.008; 
                angleX += dy * 0.008;

            } else if (pointerCount >= 2) {
                // --- МАСШТАБИРОВАНИЕ и ПЕРЕМЕЩЕНИЕ СЦЕНЫ (Two fingers) ---
                
                const newScale = getPointerDistance();
                const scaleDelta = newScale / lastScale;
                
                // 1. Pan (Перемещение)
                const centerBefore = getPointerCenter();
                
                // 2. Zoom (Масштабирование)
                scaleFactor *= scaleDelta;
                
                const centerAfter = getPointerCenter();
                
                // Коррекция смещения (Pivot Point)
                offsetX += centerBefore.x - centerAfter.x; 
                offsetY += centerBefore.y - centerAfter.y; 
                
                // Перемещение (Pan)
                const dx = e.clientX - oldX;
                const dy = e.clientY - oldY;
                
                // Применяем инкрементальный сдвиг
                offsetX += dx;
                offsetY += dy;
                
                lastScale = newScale;
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (!pointers[e.pointerId]) return;
            
            const pointer = pointers[e.pointerId];
            delete pointers[e.pointerId];
            clearTimeout(pressTimer);
            
            const movedDistance = Math.sqrt((pointer.x - pointer.startX)**2 + (pointer.y - pointer.startY)**2);

            // --- Экструзия по УДЕРЖАНИЮ (Long Press) ---
            if (isLongPress && selectedFaceIndexForExtrusion !== -1) {
                if (movedDistance < MOVE_THRESHOLD) { // Строгая проверка на отсутствие сдвига
                    extrudeFace(selectedFaceIndexForExtrusion);
                }
            }
            
            // --- Удаление (Double Tap) - Проверка на завершение второго тапа ---
            if (movedDistance < MOVE_THRESHOLD) { // Если это был Tap, а не Drag
                const now = Date.now();
                
                // Проверяем, что это второй тап в серии, и что он произошел на той же грани
                if (now - lastTapTime < DOUBLE_TAP_TIME && lastTappedFaceIndex === pointer.faceIndex && pointer.faceIndex !== -1) {
                    removeFaceByIndex(pointer.faceIndex);
                    
                    // Сброс, чтобы не допустить тройной тап
                    lastTapTime = 0;
                    lastTappedFaceIndex = -1;
                } else {
                    // Это был первый тап
                    lastTapTime = now;
                    lastTappedFaceIndex = pointer.faceIndex;
                }
            } else {
                // Это был Drag (вращение), сбрасываем Double Tap
                lastTapTime = 0;
                lastTappedFaceIndex = -1;
            }

            // --- Сброс состояний Long Press ---
            isLongPress = false;
            selectedFaceIndexForExtrusion = -1;
            
            if (Object.keys(pointers).length === 1) {
                lastScale = 1;
            }
        });
        
        // Предотвращаем стандартное контекстное меню при долгом нажатии
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // --- Запуск ---
        resizeCanvas(); 
        window.addEventListener('resize', resizeCanvas); 
        drawCube();
    </script>

</body>
</html>