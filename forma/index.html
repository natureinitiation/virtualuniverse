<!DOCTYPE html>
<html>
<head>
    <title>Forma: 3D-Редактор с Жестами и Реалистичным Приближением</title>
    <style>
        /* Стиль для стабильной работы и кнопок */
        html, body {
            height: 100%; 
            margin: 0; 
            background-color: #222;
            -webkit-user-select: none; 
            -moz-user-select: none;    
            -ms-user-select: none;     
            user-select: none; 
            touch-action: none; 
            overflow: hidden;
        }
        canvas { 
            width: 100vw; 
            height: 100vh; 
        } 
        /* Стиль для невидимых кнопок-ссылок */
        .control-button {
            position: absolute;
            color: rgba(255, 255, 255, 0.7);
            font: bold 16px sans-serif;
            cursor: pointer;
            text-decoration: none;
            padding: 10px 20px;
            text-align: center;
            z-index: 100;
        }
        #start-button { top: 30px; left: 30px; }
        #readme-button { top: 30px; right: 30px; } /* Переименовано */
        #step-button { bottom: 30px; left: 50%; transform: translateX(-50%); } /* Переименовано */
    </style>
</head>
<body>

    <canvas id="cubeCanvas"></canvas> 
    <a id="start-button" class="control-button" onclick="home(); return false;">start</a>
    <a id="readme-button" class="control-button" href="https://natureinitiation.github.io/virtualuniverse/forma/readme.md" target="_blank">help</a> <a id="step-button" class="control-button" onclick="stepForward(); return false;">step</a> <script>
        const canvas = document.getElementById('cubeCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- ОСНОВНЫЕ ПЕРЕМЕННЫЕ ---
        let width, height, center = {};
        let angleX = 0.8, angleY = 1.0; 
        
        const BASE_CUBE_SIZE = 100; 
        let Z_OFFSET = 0; // Смещение объекта по оси Z (управляет приближением/отдалением)
        const MIN_Z_OFFSET = -300; // Ограничение: предотвращает "прохождение" сквозь объект
        const STEP_DISTANCE = 30; // Расстояние для пошагового перемещения
        
        // --- КОНСТАНТЫ КАМЕРЫ И ПОЛЕТА ---
        const HOME_STATE = { angleX: 0.8, angleY: 1.0, offsetX: 0, offsetY: 0, zOffset: 0 }; 
        
        // --- ИСТОЧНИКИ СВЕТА (без изменений) ---
        const lights = [
            { dir: normalizeVector([1, 1, 1]), color: [255, 255, 255] }, 
            { dir: normalizeVector([-1, 0, 1]), color: [255, 0, 0] },     
            { dir: normalizeVector([0, 1, -1]), color: [0, 0, 255] },     
            { dir: normalizeVector([1, -1, 0]), color: [0, 255, 0] }      
        ];
        const AMBIENT_INTENSITY = 0.3; 
        
        // --- ПЕРЕМЕННЫЕ УПРАВЛЕНИЯ ---
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 20;

        let pointers = {}; 
        let lastDistance = 0; // Для Pinch-Zoom
        let offsetX = HOME_STATE.offsetX; 
        let offsetY = HOME_STATE.offsetY; 
        
        let pressTimer = null;
        let isLongPress = false;
        let selectedFaceIndexForExtrusion = -1;
        const LONG_PRESS_THRESHOLD = 500; 
        let tapCount = 0;
        let tapTimeout = null;
        let lastTappedFaceIndex = -1;
        const TAP_INTERVAL = 300; 
        const MOVE_THRESHOLD = 5; 
        
        let geometry = createCube(BASE_CUBE_SIZE);
        saveState(); 

        // --- ФУНКЦИИ ИСТОРИИ И НАВИГАЦИИ (обновлена home) ---
        function saveState() { 
            if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); }
            // Сохраняем Z_OFFSET как часть состояния, чтобы можно было отменить/повторить
            history.push(JSON.stringify({ geometry: geometry, zOffset: Z_OFFSET }));
            if (history.length > MAX_HISTORY) { history.shift(); } else { historyIndex++; }
        }

        function undo() { 
            if (historyIndex > 0) { 
                historyIndex--; 
                loadState(historyIndex); 
            } 
        }
        function redo() { 
            if (historyIndex < history.length - 1) { 
                historyIndex++; 
                loadState(historyIndex); 
            } 
        }
        function loadState(index) { 
            const state = JSON.parse(history[index]);
            geometry = state.geometry; 
            Z_OFFSET = state.zOffset; 
        }
        
        function home() {
            angleX = HOME_STATE.angleX;
            angleY = HOME_STATE.angleY;
            offsetX = HOME_STATE.offsetX;
            offsetY = HOME_STATE.offsetY;
            Z_OFFSET = HOME_STATE.zOffset;
        }

        // ОБНОВЛЕННАЯ ФУНКЦИЯ ДЛЯ КНОПКИ STEP
        function stepForward() {
            Z_OFFSET = Math.max(MIN_Z_OFFSET, Z_OFFSET - STEP_DISTANCE);
            saveState(); // Сохраняем новое Z-смещение
        }

        // --- МАТЕМАТИКА 3D (обновлена project) ---
        function normalizeVector(v) { /* ... */
            const length = Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
            return (length === 0) ? [0, 0, 0] : [v[0] / length, v[1] / length, v[2] / length];
        }

        function dotProduct(v1, v2) { /* ... */
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        function rotateX(point, angle) { /* ... */
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x, y * cos - z * sin, z * cos + y * sin];
        }

        function rotateY(point, angle) { /* ... */
            const [x, y, z] = point;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return [x * cos + z * sin, y, z * cos - x * sin];
        }

        // КЛЮЧЕВАЯ ФУНКЦИЯ ПРОЕКЦИИ
        function project(point) {
            const fov = 500; 
            // Эффективная глубина = Z объекта + Z смещение
            const effectiveZ = point[2] + Z_OFFSET; 
            const scale = fov / (fov + effectiveZ); 
            
            // Отсечение за плоскостью ближнего клиппинга
            if (effectiveZ <= -fov + 1) { 
                return [center.x, center.y]; 
            }

            // Убрали scaleFactor. Приближение/Отдаление теперь происходит ТОЛЬКО через Z_OFFSET.
            return [
                (point[0]) * scale + center.x + offsetX, 
                (point[1]) * scale + center.y + offsetY
            ];
        }
        
        function getFaceNormal(p1, p2, p3) { /* ... */
            const v1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            const v2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];
            return [
                v1[1] * v2[2] - v1[2] * v2[1],
                v1[2] * v2[0] - v1[0] * v2[2],
                v1[0] * v2[1] - v1[1] * v2[0]
            ];
        }
        
        // --- ГЕОМЕТРИЯ И РЕДАКТИРОВАНИЕ (без изменений) ---

        function createCube(a) { /* ... */
            const vertices = [
                [-a, -a, -a], [ a, -a, -a], [ a,  a, -a], [-a,  a, -a], 
                [-a, -a,  a], [ a, -a,  a], [ a,  a,  a], [-a,  a,  a]  
            ];
            const faces = [
                { indices: [0, 1, 2, 3], color: '#3333aa', opacity: 1.0, specular: false },
                { indices: [4, 5, 6, 7], color: '#33aa33', opacity: 1.0, specular: false },
                { indices: [1, 5, 6, 2], color: '#aa3333', opacity: 1.0, specular: false },
                { indices: [0, 4, 7, 3], color: '#aaaa33', opacity: 1.0, specular: false },
                { indices: [3, 7, 6, 2], color: '#33aaaa', opacity: 1.0, specular: false },
                { indices: [0, 4, 5, 1], color: '#aa33aa', opacity: 1.0, specular: false }
            ];
            return { vertices, faces };
        }
        
        function extrudeFace(faceIndex) {
            const face = geometry.faces[faceIndex];
            const oldVerticesIndices = face.indices;
            
            const nP1 = geometry.vertices[oldVerticesIndices[0]];
            const nP2 = geometry.vertices[oldVerticesIndices[1]];
            const nP3 = geometry.vertices[oldVerticesIndices[2]];
            const normal = getFaceNormal(nP1, nP2, nP3);
            const unitNormal = normalizeVector(normal);

            const newVertices = [];
            for (const vIndex of oldVerticesIndices) {
                const oldV = geometry.vertices[vIndex];
                const newV = [
                    oldV[0] + unitNormal[0] * BASE_CUBE_SIZE, 
                    oldV[1] + unitNormal[1] * BASE_CUBE_SIZE,
                    oldV[2] + unitNormal[2] * BASE_CUBE_SIZE 
                ];
                newVertices.push(newV);
            }
            
            const newVerticesStartIdx = geometry.vertices.length;
            geometry.vertices.push(...newVertices);

            const newFace = { indices: [newVerticesStartIdx, newVerticesStartIdx + 1, newVerticesStartIdx + 2, newVerticesStartIdx + 3], color: face.color, opacity: face.opacity, specular: face.specular };
            geometry.faces.push(newFace);

            const connectingFaces = [
                { indices: [oldVerticesIndices[0], oldVerticesIndices[1], newVerticesStartIdx + 1, newVerticesStartIdx + 0], color: face.color, opacity: face.opacity, specular: face.specular },
                { indices: [oldVerticesIndices[1], oldVerticesIndices[2], newVerticesStartIdx + 2, newVerticesStartIdx + 1], color: face.color, opacity: face.opacity, specular: face.specular },
                { indices: [oldVerticesIndices[2], oldVerticesIndices[3], newVerticesStartIdx + 3, newVerticesStartIdx + 2], color: face.color, opacity: face.opacity, specular: face.specular },
                { indices: [oldVerticesIndices[3], oldVerticesIndices[0], newVerticesStartIdx + 0, newVerticesStartIdx + 3], color: face.color, opacity: face.opacity, specular: face.specular },
            ];
            geometry.faces.push(...connectingFaces);
            
            geometry.faces.splice(faceIndex, 1);
            saveState();
        }

        function removeFaceByIndex(faceIndex) { /* ... */
             if (faceIndex !== -1 && faceIndex < geometry.faces.length) {
                geometry.faces.splice(faceIndex, 1);
                saveState();
             }
        }

        function toggleFaceOpacity(faceIndex) { /* ... */
            if (faceIndex !== -1 && faceIndex < geometry.faces.length) {
                const face = geometry.faces[faceIndex];
                face.opacity = (face.opacity === 1.0) ? 0.5 : 1.0;
                saveState();
            }
        }
        
        function toggleFaceSpecular(faceIndex) { /* ... */
            if (faceIndex !== -1 && faceIndex < geometry.faces.length) {
                const face = geometry.faces[faceIndex];
                face.specular = !face.specular;
                saveState();
            }
        }
        
        // --- ОТРИСОВКА (Убрано автоматическое движение) ---
        
        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            center = { x: width / 2, y: height / 2 };
        }

        let projectedFacesData = []; 

        function drawCube() {
            ctx.clearRect(0, 0, width, height); 
            
            const transformedVertices = [];
            for (const vertex of geometry.vertices) {
                let p = [...vertex]; 
                p = rotateX(p, angleX);
                p = rotateY(p, angleY);
                transformedVertices.push(p);
            }
            
            projectedFacesData = [];

            for (let i = 0; i < geometry.faces.length; i++) {
                const face = geometry.faces[i];
                const vIndices = face.indices;
                
                if (vIndices.length < 3) continue;

                const p1 = transformedVertices[vIndices[0]];
                const p2 = transformedVertices[vIndices[1]];
                const p3 = transformedVertices[vIndices[2]];
                
                const faceNormal = normalizeVector(getFaceNormal(p1, p2, p3));
                
                // ... (расчет освещения)
                let finalR = 0, finalG = 0, finalB = 0;
                const baseColor = parseInt(face.color.substring(1), 16);
                const baseR = (baseColor >> 16) & 255;
                const baseG = (baseColor >> 8) & 255;
                const baseB = baseColor & 255;

                finalR += baseR * AMBIENT_INTENSITY;
                finalG += baseG * AMBIENT_INTENSITY;
                finalB += baseB * AMBIENT_INTENSITY;

                for (const light of lights) {
                    const NdotL = dotProduct(faceNormal, light.dir);
                    
                    if (NdotL > 0) {
                        finalR += baseR * light.color[0] / 255 * NdotL;
                        finalG += baseG * light.color[1] / 255 * NdotL;
                        finalB += baseB * light.color[2] / 255 * NdotL;

                        if (face.specular) {
                            const viewDir = normalizeVector([0, 0, 1]); 
                            const H = normalizeVector([light.dir[0] + viewDir[0], light.dir[1] + viewDir[1], light.dir[2] + viewDir[2]]); 
                            const NdotH = dotProduct(faceNormal, H);
                            
                            if (NdotH > 0) {
                                const specularPower = 10; 
                                const specularIntensity = Math.pow(NdotH, specularPower) * 0.3;

                                finalR += light.color[0] * specularIntensity;
                                finalG += light.color[1] * specularIntensity;
                                finalB += light.color[2] * specularIntensity;
                            }
                        }
                    }
                }
                
                finalR = Math.min(255, finalR);
                finalG = Math.min(255, finalG);
                finalB = Math.min(255, finalB);

                const projectedCoords = vIndices.map(idx => project(transformedVertices[idx]));
                
                if (projectedCoords.some(c => !isFinite(c[0]) || !isFinite(c[1]))) continue;


                projectedFacesData.push({
                    index: i,
                    coords: projectedCoords,
                    rgb: `rgb(${Math.floor(finalR)}, ${Math.floor(finalG)}, ${Math.floor(finalB)})`,
                    opacity: face.opacity, 
                    depth: (p1[2] + p2[2] + p3[2] + (vIndices.length > 3 ? transformedVertices[vIndices[3]][2] : p3[2])) / vIndices.length 
                });
            }
            
            projectedFacesData.sort((a, b) => b.depth - a.depth); 

            for (const faceData of projectedFacesData) {
                ctx.globalAlpha = faceData.opacity;
                ctx.fillStyle = faceData.rgb;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;

                ctx.beginPath();
                ctx.moveTo(faceData.coords[0][0], faceData.coords[0][1]);
                for (let j = 1; j < faceData.coords.length; j++) {
                    ctx.lineTo(faceData.coords[j][0], faceData.coords[j][1]);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0; 
            
            requestAnimationFrame(drawCube);
        }
        
        // --- ЛОГИКА УПРАВЛЕНИЯ ЖЕСТАМИ (обновлен Pinch-Zoom) ---
        
        function getCanvasPosition(e) { /* ... */
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function getPointerCenter() { /* ... */
            const keys = Object.keys(pointers);
            if (keys.length < 2) return null;
            const p1 = pointers[keys[0]];
            const p2 = pointers[keys[1]];
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function getPointerDistance() { /* ... */
            const keys = Object.keys(pointers);
            if (keys.length < 2) return 0;
            const p1 = pointers[keys[0]];
            const p2 = pointers[keys[1]];
            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
        }

        function getFaceIndexAtPoint(pos) { 
            for (let i = projectedFacesData.length - 1; i >= 0; i--) { 
                const faceData = projectedFacesData[i];
                if (pos.y > 80 && pos.y < height - 80 && isPointInPolygon({x: pos.x, y: pos.y}, faceData.coords)) {
                    return faceData.index;
                }
            }
            return -1;
        }

        function isPointInPolygon(point, polygon) { 
            let x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i][0], yi = polygon[i][1];
                let xj = polygon[j][0], yj = polygon[j][1];
                let intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // --- Обработчики событий ---

        canvas.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.control-button')) return; 

            const canvasPos = getCanvasPosition(e);
            const faceIndex = getFaceIndexAtPoint(canvasPos);
            
            pointers[e.pointerId] = { 
                x: e.clientX, y: e.clientY, startX: e.clientX, startY: e.clientY, faceIndex: faceIndex 
            };
            
            const pointerCount = Object.keys(pointers).length;
            
            if (pointerCount === 1) {
                clearTimeout(tapTimeout);
                isLongPress = false;
                selectedFaceIndexForExtrusion = faceIndex;
                if (faceIndex !== -1) {
                    pressTimer = setTimeout(() => { isLongPress = true; }, LONG_PRESS_THRESHOLD);
                }
            } else if (pointerCount === 2) {
                clearTimeout(pressTimer);
                isLongPress = false;
                tapCount = 0;
                lastDistance = getPointerDistance(); // Обновлено
            }
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!pointers[e.pointerId] || e.target.closest('.control-button')) return;

            const oldX = pointers[e.pointerId].x;
            const oldY = pointers[e.pointerId].y;

            pointers[e.pointerId].x = e.clientX;
            pointers[e.pointerId].y = e.clientY;

            const pointerCount = Object.keys(pointers).length;
            
            if (pointerCount === 1) {
                const movedDistance = Math.sqrt((e.clientX - pointers[e.pointerId].startX)**2 + (e.clientY - pointers[e.pointerId].startY)**2);
                if (pressTimer && movedDistance > MOVE_THRESHOLD) {
                    clearTimeout(pressTimer);
                    isLongPress = false;
                }
                
                const dx = e.clientX - oldX;
                const dy = e.clientY - oldY;
                angleY += dx * 0.008; 
                angleX += dy * 0.008;

            } else if (pointerCount >= 2) {
                const newDistance = getPointerDistance();
                const distanceDelta = newDistance - lastDistance; // Изменение расстояния
                
                // ZOOM (Приближение/Отдаление через Z-смещение)
                const zoomSpeed = 2; // Чувствительность зума
                
                // Изменение Z_OFFSET для приближения/отдаления
                Z_OFFSET -= distanceDelta * zoomSpeed; 
                
                // Ограничение: предотвращение прохождения сквозь объект
                Z_OFFSET = Math.max(MIN_Z_OFFSET, Z_OFFSET);
                
                // Pan
                const dx = e.clientX - oldX;
                const dy = e.clientY - oldY;
                offsetX += dx;
                offsetY += dy;
                
                lastDistance = newDistance; // Обновлено
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            if (!pointers[e.pointerId] || e.target.closest('.control-button')) return;
            
            const pointer = pointers[e.pointerId];
            delete pointers[e.pointerId];
            clearTimeout(pressTimer);
            
            const movedDistance = Math.sqrt((pointer.x - pointer.startX)**2 + (pointer.y - pointer.startY)**2);
            
            if (movedDistance > MOVE_THRESHOLD) {
                isLongPress = false;
                return;
            }

            // Long Press (Экструзия)
            if (isLongPress && selectedFaceIndexForExtrusion !== -1) {
                extrudeFace(selectedFaceIndexForExtrusion);
                isLongPress = false;
                selectedFaceIndexForExtrusion = -1;
                return; 
            }
            
            // Tap Logic
            tapCount++;
            
            if (tapCount === 1) {
                lastTappedFaceIndex = pointer.faceIndex;
                tapTimeout = setTimeout(() => {
                    if (lastTappedFaceIndex !== -1) {
                        removeFaceByIndex(lastTappedFaceIndex);
                    } else {
                        undo();
                    }
                    tapCount = 0;
                }, TAP_INTERVAL);
            } else if (tapCount === 2) {
                clearTimeout(tapTimeout);
                if (pointer.faceIndex !== -1 && lastTappedFaceIndex === pointer.faceIndex) {
                    toggleFaceOpacity(pointer.faceIndex);
                } else if (pointer.faceIndex === -1 && lastTappedFaceIndex === -1) {
                    redo();
                }
                tapTimeout = setTimeout(() => { tapCount = 0; }, TAP_INTERVAL);
            } else if (tapCount === 3) {
                clearTimeout(tapTimeout);
                if (pointer.faceIndex !== -1 && lastTappedFaceIndex === pointer.faceIndex) {
                    toggleFaceSpecular(pointer.faceIndex);
                }
                tapCount = 0;
            }

            selectedFaceIndexForExtrusion = -1;
            // Сохраняем состояние после завершения жеста, чтобы можно было отменить/повторить
            if (Object.keys(pointers).length === 0) { saveState(); } 
        });
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // --- ЗАПУСК ---
        resizeCanvas(); 
        window.addEventListener('resize', resizeCanvas); 
        drawCube();
    </script>

</body>
</html>
