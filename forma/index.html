<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Forma Base - Reflected V18 - Color BG & Clean UI</title>
    <link rel="manifest" href="manifest.json"> 
    <style>
        body {
            user-select: none; 
            margin: 0;
            overflow: hidden;
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
        }
        body { margin: 0; overflow: hidden; background: #000; } 

        .control-button, .top-control { 
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            width: auto;
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9) !important; 
            display: flex;
            align-items: center;
            justify-content: center;
            /* Убираем рамки и фон у кнопок */
            border: none;
            padding: 0;
            background: none;
        }

        /* Further, Closer, Fly/Stop - Нижний блок */
        .control-button { 
            bottom: 20px;
        }

        /* Further - слева */
        .further-button {
            left: 5%; 
            right: auto;
        }

        /* Closer - справа */
        .closer-button {
            right: 5%; 
            left: auto;
        }
            
        /* Fly/Stop - внизу по центру */
        .fly-button {
            left: 50%; 
            transform: translateX(-50%);
        }

        /* Load, Reset, Save - Верхний блок */
        .top-control {
            top: 20px;
        }
        
        /* Load - Верхний левый угол */
        .load-button {
            left: 5%;
            transform: none;
        }
        /* Reset - Верхний центр */
        .reset-button {
            left: 50%;
            transform: translateX(-50%);
        }
        /* Save - Верхний правый угол */
        .save-button {
            right: 5%;
            left: auto;
            transform: none;
        }
            
        .hidden {
            display: none;
        }
        .secret {
            position: fixed;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 18px;
            color: white;
            text-decoration: none;
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            z-index: 1000;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

    </style>
</head>
<body>
    <div class="control-button further-button">Further</div> 
    <div class="control-button closer-button">Closer</div> 
    <div class="control-button fly-button">Fly</div> 
    
    <div class="top-control load-button">Load</div> 
    <div class="top-control reset-button">Reset</div> 
    <div class="top-control save-button">Save</div> 
    
    <input type="file" id="file-input" style="display: none;" accept=".json"> 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// Imports 
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff); // Возвращаем синий фон
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30; 
const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Настройки полета (УЛЬТРА-ПЛАВНАЯ ДИНАМИКА) ---
let isFlying = false;
let currentSpeed = 0.0;             
const MAX_SPEED = 0.3;              
const ACCELERATION = 0.00033;        
const DECCELERATION = 0.00033;        
// -------------------------------------------------------------

// --- Background color change (Возвращаем анимацию) ---
const colors = ['#006ee5', '#000033'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 5;
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000); // Снова включено

// --- Controls and lights (с изменением зума) ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;

// !!! ВАЖНОЕ ИЗМЕНЕНИЕ: ВКЛЮЧАЕМ СТАНДАРТНЫЙ ZOOM ДЛЯ PINCH-TO-ZOOM
controls.enableZoom = true; 
controls.zoomSpeed = 0.5; 

controls.enablePan = true;
controls.panSpeed = 0.3;  

// 1. Общий свет (AmbientLight)
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
scene.add(ambientLight);

// Создаем группу для света, который будет двигаться с камерой
const cameraLightGroup = new THREE.Group();
camera.add(cameraLightGroup); 
scene.add(camera); 

// 2. Внешний Directional Light (для бликов)
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
directionalLight.position.set(0, 0, 10); 
cameraLightGroup.add(directionalLight);

// 3. Внешний Цветной Directional Light (сзади)
const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 1.0);
ultramarineLight.position.set(0, 0, -10); 
cameraLightGroup.add(ultramarineLight);
// -----------------------------

// Word-links (без изменений)
const secrets = ['slowly', 'focus', 'try', 'switch', 'scroll', 'scale', 'shift', 'move', 'tap', 'touch', 'click', 'right', 'button', 'mouse', 'screen', 'fly', 'double', 'follow', 'read', 'peer', 'rest', 'quick', 'hold', 'and', 'or', 'virtual', 'eternity', 'node', 'server', 'idea', 'word', 'victory', 'release', 'keep', 'calm', 'relax', 'rest', 'leave', 'chance', 'mine', 'token', 'visual', 'reality', 'space', 'polarity', 'keep', 'mind', 'think', 'dream', 'fantasy', 'trade', 'change', 'place', 'invest', 'look', 'ask', 'find', 'sign', 'type', 'play', 'experiment', 'phenomena', 'coordinate', 'carry', 'spend', 'accept', 'bring', 'transfer', 'take', 'sell', 'market', 'stay', 'well', 'top', 'hit'];


// Object storage
let formaCubeFaces = []; 
const activePoints = [];
const collisionRaycaster = new THREE.Raycaster();

// --- ЛОГИКА КУБА ИЗ 6 ГРАНЕЙ (Forma Base) ---
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 

// Функция для добавления внутреннего света (Слабый Теплый Свет)
function addInternalLights(group) {
    const warmInternalLight = new THREE.PointLight(0xffaa00, 0.01, 0); 
    warmInternalLight.position.set(0, 0, 0); 
    group.add(warmInternalLight);
}


// КОНФИГУРАЦИЯ ГРАНЕЙ (без изменений)
const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },     
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },    
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },    
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },    
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },             
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },      
];

const getOppositeFaceId = (normal) => {
    let bestMatchId = -1;
    let minDot = Infinity; 

    FACE_CONFIGS.forEach(config => {
        const dot = config.normal.dot(normal); 
        
        if (dot < minDot) {
            minDot = dot;
            bestMatchId = config.id;
        }
    });
    
    return bestMatchId;
};

// Функция для создания отдельной грани куба
const createCubeFace = (config) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    
    // **МАТЕРИАЛ: roughness 0.5 (полированный металл)**
    const material = new THREE.MeshStandardMaterial({
        color: config.color, 
        roughness: 0.5,    
        metalness: 1.0,    
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 1.0,      
        envMap: scene.background, 
    });
    
    const face = new THREE.Mesh(faceGeometry, material);
    face.position.set(...config.pos);
    face.rotation.set(...config.rot);
    face.name = `face_${config.id}`; 
    // Добавляем user data для сохранения/загрузки состояния прозрачности
    face.userData = { 
        id: config.id, 
        originalColor: config.color,
        isTransparent: false
    };

    return face;
}

/**
 * ОСНОВНАЯ ФУНКЦИЯ СОЗДАНИЯ КУБА
 * @param {THREE.Vector3} position - Позиция куба.
 * @param {number} excludeIndex - ID грани для исключения (для создания "наращивания").
 * @param {Array<{id: number, isTransparent: boolean}>} [loadedFacesState=FACE_CONFIGS] - Состояние граней для загрузки.
 */
const createFormaCube = (position, excludeIndex = -1, loadedFacesState = FACE_CONFIGS) => {
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);
    newFormaCubeGroup.userData.isFormaCube = true;

    // Определяем, какие грани нужно создать, используя FACE_CONFIGS как базу
    FACE_CONFIGS.forEach((baseConfig) => {
        
        // 1. Проверка на исключение (при наращивании)
        if (baseConfig.id === excludeIndex) return;

        // 2. Проверка, есть ли эта грань в загруженном состоянии (при загрузке из файла)
        const faceState = loadedFacesState.find(f => f.id === baseConfig.id);
        
        // Если мы загружаем мир из файла и этой грани нет, пропускаем
        if (loadedFacesState !== FACE_CONFIGS && !faceState) {
             return;
        }

        const face = createCubeFace(baseConfig);
        
        // Применяем состояние прозрачности, если оно загружено
        if (faceState && faceState.isTransparent) {
             face.material.opacity = 0.5;
             face.material.envMapIntensity = 0.5;
             face.userData.isTransparent = true;
        }

        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    
    addInternalLights(newFormaCubeGroup); 
    
    return newFormaCubeGroup;
};


// ОЧИСТКА МИРА
const clearWorld = () => {
    // Удаляем все кубы из сцены
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            // Удаляем свет и саму группу
            object.children.filter(child => child.isLight).forEach(light => object.remove(light));
            scene.remove(object);
            
            // Очищаем геометрию и материалы
            object.children.forEach(mesh => {
                if (mesh.isMesh) {
                    mesh.geometry.dispose();
                    if (mesh.material.length) {
                        mesh.material.forEach(m => m.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
        }
    });

    formaCubeFaces = [];
    formaCubeGroup = null;
}

// ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ
const initFormaCube = (position = new THREE.Vector3(0, 0, camera.position.z - 15)) => {
    clearWorld(); 

    // Проверяем localStorage на случай, если пользователь забыл сохранить (резервная копия)
    const localLoaded = loadLocalState();

    if (!localLoaded) {
        // Создаем начальный куб, если нет сохраненных данных
        formaCubeGroup = createFormaCube(position, -1); 
    }

    controls.target.set(camera.position.x, camera.position.y, camera.position.z - 15); 
    controls.update();
};
// --- КОНЕЦ ЛОГИКИ КУБА ---


// --- ЛОГИКА СОХРАНЕНИЯ/ЗАГРУЗКИ (File I/O) ---

const getWorldData = () => {
    const worldData = [];
    
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            const cubeData = {
                position: object.position.toArray(),
                faces: []
            };

            object.children.forEach(face => {
                if (face.isMesh && face.userData.id !== undefined) {
                    cubeData.faces.push({
                        id: face.userData.id,
                        isTransparent: face.userData.isTransparent
                    });
                }
            });
            // Добавляем куб, только если он содержит грани (не полностью удален)
            if (cubeData.faces.length > 0) {
                 worldData.push(cubeData);
            }
        }
    });

    const cameraData = {
        position: camera.position.toArray(),
        target: controls.target.toArray()
    };
    
    return { world: worldData, camera: cameraData };
};


// 1. СОХРАНЕНИЕ В ФАЙЛ (SaveToFile)
const saveWorldToFile = () => {
    const data = getWorldData();
    const json = JSON.stringify(data, null, 2); 
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'forma_world_' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Визуальное подтверждение
    const saveButton = document.querySelector('.save-button');
    const originalText = saveButton.textContent;
    saveButton.textContent = 'Saved!';
    setTimeout(() => {
        saveButton.textContent = originalText;
    }, 1000);
    
    // Сохраняем в localStorage как резервную копию
    localStorage.setItem('forma_world_data_local', JSON.stringify(data.world));
    localStorage.setItem('forma_camera_data_local', JSON.stringify(data.camera));
};


// 2. ЗАГРУЗКА ИЗ ФАЙЛА (LoadFromFile)
const loadWorldFromFile = (data) => {
    clearWorld(); // Сначала очищаем текущий мир

    try {
        const worldData = data.world;
        const cameraData = data.camera;

        if (!worldData || !cameraData || !Array.isArray(worldData)) throw new Error("Неверный формат файла или отсутствуют данные о мире/камере.");

        // Загрузка мира
        worldData.forEach(cubeData => {
            const position = new THREE.Vector3(...cubeData.position);
            // Создаем куб, передавая состояние граней для их восстановления
            createFormaCube(position, -1, cubeData.faces); 
        });

        // Загрузка камеры
        camera.position.fromArray(cameraData.position);
        controls.target.fromArray(cameraData.target);
        controls.update();

        // Визуальное подтверждение
        const loadButton = document.querySelector('.load-button');
        const originalText = loadButton.textContent;
        loadButton.textContent = 'Loaded!';
        setTimeout(() => {
            loadButton.textContent = originalText;
        }, 1000);

    } catch (e) {
        alert('Ошибка при загрузке файла: ' + e.message);
        initFormaCube(); // Возвращаемся к начальному состоянию
    }
};

// Обработчик события выбора файла
document.getElementById('file-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                // Проверяем, что это объект с нужными ключами
                if (typeof data !== 'object' || !data.world || !data.camera) {
                     throw new Error("Файл не содержит данных о мире ('world') или камере ('camera').");
                }
                loadWorldFromFile(data);
            } catch (error) {
                alert('Ошибка чтения файла. Убедитесь, что это правильный формат .json. Детали: ' + error.message);
            }
        };
        reader.readAsText(file);
    }
    // Сброс поля ввода файла, чтобы можно было загрузить тот же файл снова
    event.target.value = ''; 
});


// 3. ЗАГРУЗКА ИЗ LOCAL STORAGE (резервная копия при старте)
const loadLocalState = () => {
    const worldDataString = localStorage.getItem('forma_world_data_local');
    const cameraDataString = localStorage.getItem('forma_camera_data_local');

    if (!worldDataString || !cameraDataString) {
        return false;
    }
    
    const worldData = JSON.parse(worldDataString);
    const cameraData = JSON.parse(cameraDataString);

    if (worldData.length === 0) return false;

    // Восстановление мира
    worldData.forEach(cubeData => {
        const position = new THREE.Vector3(...cubeData.position);
        createFormaCube(position, -1, cubeData.faces);
    });

    // Восстановление камеры
    camera.position.fromArray(cameraData.position);
    controls.target.fromArray(cameraData.target);
    controls.update();
    
    return true; 
};


// --- ЛОГИКА ТАПА И УДЕРЖАНИЯ (без изменений) ---
let tapTimeout;
let longPressTimer;
let tapCount = 0;
const TAP_DELAY = 400; 
const LONG_PRESS_DELAY = 700; 
let isLongPress = false;

renderer.domElement.addEventListener('pointerdown', (event) => {
    if (event.target.closest('.control-button, .top-control')) return;
    event.preventDefault(); 
    
    isLongPress = false;
    clearTimeout(longPressTimer);
    
    longPressTimer = setTimeout(() => {
        isLongPress = true;
        handleLongPress(event); 
    }, LONG_PRESS_DELAY);
});

renderer.domElement.addEventListener('pointerup', (event) => {
    clearTimeout(longPressTimer); 
    
    if (isLongPress) {
        isLongPress = false;
        return; 
    }

    handleInteraction(event);
});

renderer.domElement.addEventListener('pointermove', (event) => {
    // Внимание: OrbitControls может сам отменить longPress, если это жест
    if (longPressTimer) {
        clearTimeout(longPressTimer);
    }
    isLongPress = false;
});


const handleLongPress = (event) => {
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(formaCubeFaces, false);
    
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const obj = intersection.object;
        const group = obj.parent; 

        if (group) {
            group.remove(obj);
            obj.geometry.dispose(); 
        }
        const index = formaCubeFaces.indexOf(obj);
        if (index > -1) {
            formaCubeFaces.splice(index, 1);
        }
        
        // Проверяем, остался ли в группе только свет (один ребенок, который является PointLight)
        if (group && group.children.length === 1 && group.children[0].isLight) {
            scene.remove(group);
            if (group === formaCubeGroup) {
                formaCubeGroup = null;
            }
        }
    }
    
    tapCount = 0; 
};


const handleInteraction = (event) => {
    if (event.target.closest('.control-button, .top-control')) return;
    
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(formaCubeFaces, false);
    const wordSpawnProbability = 0.3;
    
    tapCount++;
    
    if (tapTimeout) clearTimeout(tapTimeout);

    tapTimeout = setTimeout(() => {
        const currentTapCount = tapCount;
        tapCount = 0; 
        
        if (intersects.length > 0) {
            const intersection = intersects[0];
            const obj = intersection.object;
            const group = obj.parent; 

            if (currentTapCount === 2) {
                const faceNormal = intersection.face.normal.clone();
                faceNormal.transformDirection(obj.matrixWorld); 
                faceNormal.normalize();
                
                const groupWorldPos = group.position.clone();
                const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
                
                const excludeId = getOppositeFaceId(faceNormal);
                // Создаем новый куб, используя стандартные конфигурации граней
                const newCube = createFormaCube(newGroupPosition, excludeId, FACE_CONFIGS);
                
            } else if (currentTapCount === 1) {
                const face = obj;
                
                if (face.material.opacity === 1.0) {
                    face.material.opacity = 0.5;
                    face.material.envMapIntensity = 0.5; 
                    face.userData.isTransparent = true; // Сохраняем состояние
                } else {
                    face.material.opacity = 1.0;
                    face.material.envMapIntensity = 1.0; 
                    face.userData.isTransparent = false; // Сохраняем состояние
                }
                face.material.needsUpdate = true;
                
                if (Math.random() < wordSpawnProbability) {
                    const wordPos3D = intersection.point.clone(); 
                    const wordPos2D = wordPos3D.project(camera);
                    const wordX = (wordPos2D.x * 0.5 + 0.5) * window.innerWidth;
                    const wordY = (-wordPos2D.y * 0.5 + 0.5) * window.innerHeight;
                    createSecret(wordX, wordY);
                }
            }
            
        } 
    }, TAP_DELAY);
};
// --- КОНЕЦ ЛОГИКИ ТАПА И УДЕРЖАНИЯ ---


// ... (Word spawning functions, без изменений) ...
function createSecret(x, y) {
    const secret = document.createElement('a');
    secret.className = 'secret';
    const word = secrets[Math.floor(Math.random() * secrets.length)];
    secret.textContent = word;

    secret.target = '_blank';
    secret.style.cssText = `
        position: fixed; left: ${x}px; top: ${y}px; transform: translate(-50%, -50%); opacity: 0;
        font-family: monospace; font-size: 18px; color: white; text-decoration: none;
        padding: 10px; border-radius: 8px; pointer-events: auto; z-index: 1000;
    `;
    document.body.appendChild(secret);

    const rect = secret.getBoundingClientRect();
    const minWordDistance = Math.max(rect.width, rect.height) + 20;
    if (isWordOccupied(x, y, minWordDistance)) {
        secret.remove();
        return;
    }

    activePoints.push({ x, y, timestamp: Date.now(), isWord: true });

    setTimeout(() => {
        secret.style.opacity = 1;
        secret.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 10);

    setTimeout(() => {
        secret.style.opacity = 0;
        secret.style.transform = 'translate(-50%, -50%) scale(0.8)';
    }, 8000);

    setTimeout(() => {
        secret.remove();
        const index = activePoints.findIndex(p => p.x === x && p.y === y && p.isWord);
        if (index !== -1) activePoints.splice(index, 1);
    }, 8500);

    secret.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        if (!e.ctrlKey && !e.metaKey && secret.href === window.location.href + '#') {
            secret.remove();
        }
    });
}

function isWordOccupied(x, y, minDistance) {
    return activePoints.some(point => {
        if (!point.isWord) return false;
        const dx = point.x - x;
        const dy = point.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < minDistance;
    });
}
// ... (конец Word spawning functions) ...


// --- ЛОГИКА КОЛЛИЗИЙ (без изменений) ---
const applyCameraRepulsion = (startPosition, direction, distanceToMove) => {
    const safeDistance = 0.5; 
    
    if (formaCubeFaces.length === 0) return distanceToMove; 

    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    
    return Math.abs(distanceToMove); 
};


// Camera movement (Closer/Further) (без изменений)
const moveCamera = (directionVector, distance) => {
    const initialPosition = camera.position.clone();
    
    const direction = directionVector.clone().normalize();
    
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const resetButton = document.querySelector('.reset-button'); 
const flyButton = document.querySelector('.fly-button');
const saveButton = document.querySelector('.save-button'); 
const loadButton = document.querySelector('.load-button');
const fileInput = document.getElementById('file-input');

closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    // Кнопка Closer (Ближе) - Move ВПЕРЕД
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    // Кнопка Further (Дальше) - Move НАЗАД
    moveCamera(direction, CUBE_SIZE); 
});

resetButton.addEventListener('click', () => {
    localStorage.removeItem('forma_world_data_local'); // Удаляем локальный резерв
    localStorage.removeItem('forma_camera_data_local');
    window.location.reload(); 
});

saveButton.addEventListener('click', saveWorldToFile); // Привязка к скачиванию файла

loadButton.addEventListener('click', () => {
    fileInput.click(); // Имитируем клик по скрытому полю ввода файла
});


// !!! ВАЖНОЕ ИЗМЕНЕНИЕ: УДАЛЕН КАСТОМНЫЙ ОБРАБОТЧИК 'wheel'.
// Теперь OrbitControls автоматически обрабатывает колесико мыши и pinch-to-zoom (щипок)
// для изменения FOV, так как controls.enableZoom = true.


// --- Обработчик кнопки "Fly" (без изменений) ---
flyButton.addEventListener('click', () => {
    isFlying = !isFlying;
    if (isFlying) {
        flyButton.textContent = 'Stop';
    } else {
        flyButton.textContent = 'Fly';
    }
});
// ----------------------------------------------

// Animation loop (без изменений)
const animate = () => {
    controls.update();

    // 1. ЛОГИКА РАЗГОНА И ТОРМОЖЕНИЯ
    if (isFlying) {
        // Разгон: Увеличиваем currentSpeed до MAX_SPEED
        currentSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
        // Торможение: Уменьшаем currentSpeed до 0
        currentSpeed = Math.max(currentSpeed - DECCELERATION, 0.0);
    }
    
    // 2. ДВИЖЕНИЕ
    if (currentSpeed > 0) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        moveCamera(direction, currentSpeed); 
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};
// ---------------------------------------------

// Resize handling (без изменений)
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ИНИЦИАЛИЗАЦИЯ КУБА
initFormaCube();
animate();

    </script>
</body>
</html>
