<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Forma Base - V25 - Rhombus D-Pad</title>
    <link rel="manifest" href="manifest.json"> 
    <style>
        body {
            user-select: none; 
            margin: 0;
            overflow: hidden;
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
        }
        body { margin: 0; overflow: hidden; background: #000; } 

        .control-button, .top-control { 
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            width: auto;
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.9) !important; 
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            padding: 0;
            background: none;
        }

        /* Further, Closer, Fly/Stop - Нижний блок */
        .control-button { 
            bottom: 20px;
        }

        /* Further - слева */
        .further-button {
            left: 5%; 
            right: auto;
        }

        /* Closer - справа */
        .closer-button {
            right: 5%; 
            left: auto;
        }
            
        /* Fly/Stop - внизу по центру */
        .fly-button {
            left: 50%; 
            transform: translateX(-50%);
        }

        /* Load, Reset, Save - Верхний блок */
        .top-control {
            top: 20px;
        }
        
        /* Load - Верхний левый угол */
        .load-button {
            left: 5%;
            transform: none;
        }
        /* Reset - Верхний центр */
        .reset-button {
            left: 50%;
            transform: translateX(-50%);
        }
        /* Save - Верхний правый угол */
        .save-button {
            right: 5%;
            left: auto;
            transform: none;
        }
        
        /* НОВЫЙ БЛОК: Кнопки движения (Ромбовидное расположение) */
        .dir-button {
            position: fixed;
            z-index: 1000;
            cursor: pointer;
            border: none;
            background: none;
            padding: 10px; 
            /* Гарантируем, что кнопки выше, чем остальные элементы управления */
            z-index: 1001; 
        }

        /* Стиль для использования изображений */
        .dir-button img {
            width: 40px; 
            height: 40px; 
            filter: brightness(0.9); 
        }
        
        /* Размещаем по краям экрана в форме ромба */
        .dir-up {
            top: 25%; /* 25% от верха */
            left: 50%;
            transform: translate(-50%, -50%); 
        }
        .dir-down {
            bottom: 25%; /* 25% от низа */
            left: 50%;
            transform: translate(-50%, 50%); 
        }
        .dir-left {
            left: 5%; /* 5% от левого края */
            top: 50%;
            transform: translateY(-50%); 
        }
        .dir-right {
            right: 5%; /* 5% от правого края */
            top: 50%;
            transform: translateY(-50%); 
        }
            
        .hidden {
            display: none;
        }
        .secret {
            position: fixed;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 18px;
            color: white;
            text-decoration: none;
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            z-index: 1000;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

    </style>
</head>
<body>
    <div class="control-button further-button">Further</div> 
    <div class="control-button closer-button">Closer</div> 
    <div class="control-button fly-button">Fly</div> 
    
    <div class="top-control load-button">Load</div> 
    <div class="top-control reset-button">Reset</div> 
    <div class="top-control save-button">Save</div> 
    
    <button class="dir-button dir-up"><img src="https://natureinitiation.github.io/virtualuniverse/forma/Arrows.001.png" alt="Up"></button> 
    <button class="dir-button dir-down"><img src="https://natureinitiation.github.io/virtualuniverse/forma/Arrows.003.png" alt="Down"></button> 
    <button class="dir-button dir-left"><img src="https://natureinitiation.github.io/virtualuniverse/forma/Arrows.004.png" alt="Left"></button> 
    <button class="dir-button dir-right"><img src="https://natureinitiation.github.io/virtualuniverse/forma/Arrows.002.png" alt="Right"></button> 
    
    <input type="file" id="file-input" style="display: none;" accept=".json"> 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// Imports 
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff); 
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 0.001); 
const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Настройки полета ---
let isFlying = false;
let currentSpeed = 0.0;             
const MAX_SPEED = 0.3;              
const ACCELERATION = 0.00033;        
const DECCELERATION = 0.00033;        
// -------------------------------------------------------------

// --- Background color change (без изменений) ---
const colors = ['#006ee5', '#f84d54', '#000033', '#f84d54'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 5;
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000); 

// --- Controls (ОТКЛЮЧЕНЫ PAN и ZOOM, включен только ROTATE) ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;

// Полностью отключаем Pan и Zoom, чтобы избежать прохождения сквозь грани
controls.enableZoom = false; 
controls.enablePan = false;  

// Конфигурируем жесты и мышь
controls.touches = {
    ONE: THREE.TOUCH.ROTATE,  
    TWO: THREE.TOUCH.NONE,    
};
controls.mouseButtons = {
    LEFT: THREE.MOUSE.ROTATE,
    MIDDLE: THREE.MOUSE.NONE, 
    RIGHT: THREE.MOUSE.NONE,  
};

controls.zoomSpeed = 0.5; 
controls.panSpeed = 0.3;  

// --- Light and Camera Setup (без изменений) ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
scene.add(ambientLight);

const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.5); // (Цвет неба, Цвет земли, Интенсивность)
scene.add(hemisphereLight);

const cameraLightGroup = new THREE.Group();
camera.add(cameraLightGroup); 
scene.add(camera); 

const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
directionalLight.position.set(0, 0, 10); 
cameraLightGroup.add(directionalLight);

const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 1.0);
ultramarineLight.position.set(0, 0, -10); 
cameraLightGroup.add(ultramarineLight);
// -----------------------------

// Word-links (без изменений)
const secrets = ['slowly', 'focus', 'try', 'switch', 'scroll', 'scale', 'shift', 'move', 'tap', 'touch', 'click', 'right', 'button', 'mouse', 'screen', 'fly', 'double', 'follow', 'read', 'peer', 'rest', 'quick', 'hold', 'and', 'or', 'virtual', 'eternity', 'node', 'server', 'idea', 'word', 'victory', 'release', 'keep', 'calm', 'relax', 'rest', 'leave', 'chance', 'mine', 'token', 'visual', 'reality', 'space', 'polarity', 'keep', 'mind', 'think', 'dream', 'fantasy', 'trade', 'change', 'place', 'invest', 'look', 'ask', 'find', 'sign', 'type', 'play', 'experiment', 'phenomena', 'coordinate', 'carry', 'spend', 'accept', 'bring', 'transfer', 'take', 'sell', 'market', 'stay', 'well', 'top', 'hit'];


// Object storage
let formaCubeFaces = []; 
const activePoints = [];
const collisionRaycaster = new THREE.Raycaster();

// --- ЛОГИКА КУБА ИЗ 6 ГРАНЕЙ (Forma Base) (без изменений) ---
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 

function addInternalLights(group) {
    const warmInternalLight = new THREE.PointLight(0xffaa00, 0.05, 0); 
    warmInternalLight.position.set(0, 0, 0); 
    group.add(warmInternalLight);
}


const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },     
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },    
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },    
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },    
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },             
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },      
];

const getOppositeFaceId = (normal) => {
    let bestMatchId = -1;
    let minDot = Infinity; 

    FACE_CONFIGS.forEach(config => {
        const dot = config.normal.dot(normal); 
        
        if (dot < minDot) {
            minDot = dot;
            bestMatchId = config.id;
        }
    });
    
    return bestMatchId;
};

const createCubeFace = (config) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    
    const material = new THREE.MeshStandardMaterial({
        color: config.color, 
        roughness: 0.7,    
        metalness: 1.0,    
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 1.0,      
        envMap: scene.background, 
    });
    
    const face = new THREE.Mesh(faceGeometry, material);
    face.position.set(...config.pos);
    face.rotation.set(...config.rot);
    face.name = `face_${config.id}`; 
    face.userData = { 
        id: config.id, 
        originalColor: config.color,
        isTransparent: false
    };

    return face;
}

const createFormaCube = (position, excludeIndex = -1, loadedFacesState = FACE_CONFIGS) => {
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);
    newFormaCubeGroup.userData.isFormaCube = true;

    FACE_CONFIGS.forEach((baseConfig) => {
        
        if (baseConfig.id === excludeIndex) return;

        const faceState = loadedFacesState.find(f => f.id === baseConfig.id);
        
        if (loadedFacesState !== FACE_CONFIGS && !faceState) {
             return;
        }

        const face = createCubeFace(baseConfig);
        
        if (faceState && faceState.isTransparent) {
             face.material.opacity = 0.5;
             face.material.envMapIntensity = 0.5;
             face.userData.isTransparent = true;
        }

        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    
    addInternalLights(newFormaCubeGroup); 
    
    return newFormaCubeGroup;
};


const clearWorld = () => {
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            object.children.filter(child => child.isLight).forEach(light => object.remove(light));
            scene.remove(object);
            
            object.children.forEach(mesh => {
                if (mesh.isMesh) {
                    mesh.geometry.dispose();
                    if (mesh.material.length) {
                        mesh.material.forEach(m => m.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
        }
    });

    formaCubeFaces = [];
    formaCubeGroup = null;
}

// ОСНОВНАЯ ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ
const initFormaCube = (position = new THREE.Vector3(0, 0, 0)) => { // ИЗМЕНЕНИЕ 2: Куб создается в (0, 0, 0)
    clearWorld();

    const localLoaded = loadLocalState();

    if (!localLoaded) {
        formaCubeGroup = createFormaCube(position, -1);
    }

    // ИЗМЕНЕНИЕ 3: Таргет вращения устанавливается точно в центр куба (0, 0, 0)
    controls.target.set(0, 0, 0); 
    controls.update();
};
// ... КОНЕЦ ЛОГИКИ КУБА ---


// --- ЛОГИКА СОХРАНЕНИЯ/ЗАГРУЗКИ (без изменений) ---

const getWorldData = () => {
    const worldData = [];
    
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            const cubeData = {
                position: object.position.toArray(),
                faces: []
            };

            object.children.forEach(face => {
                if (face.isMesh && face.userData.id !== undefined) {
                    cubeData.faces.push({
                        id: face.userData.id,
                        isTransparent: face.userData.isTransparent
                    });
                }
            });
            if (cubeData.faces.length > 0) {
                 worldData.push(cubeData);
            }
        }
    });

    const cameraData = {
        position: camera.position.toArray(),
        target: controls.target.toArray()
    };
    
    return { world: worldData, camera: cameraData };
};


const saveWorldToFile = () => {
    const data = getWorldData();
    const json = JSON.stringify(data, null, 2); 
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'forma_world_' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    const saveButton = document.querySelector('.save-button');
    const originalText = saveButton.textContent;
    saveButton.textContent = 'Saved!';
    setTimeout(() => {
        saveButton.textContent = originalText;
    }, 1000);
    
    localStorage.setItem('forma_world_data_local', JSON.stringify(data.world));
    localStorage.setItem('forma_camera_data_local', JSON.stringify(data.camera));
};


const loadWorldFromFile = (data) => {
    clearWorld(); 

    try {
        const worldData = data.world;
        const cameraData = data.camera;

        if (!worldData || !cameraData || !Array.isArray(worldData)) throw new Error("Неверный формат файла или отсутствуют данные о мире/камере.");

        worldData.forEach(cubeData => {
            const position = new THREE.Vector3(...cubeData.position);
            createFormaCube(position, -1, cubeData.faces); 
        });

        camera.position.fromArray(cameraData.position);
        controls.target.fromArray(cameraData.target);
        controls.update();

        const loadButton = document.querySelector('.load-button');
        const originalText = loadButton.textContent;
        loadButton.textContent = 'Loaded!';
        setTimeout(() => {
            loadButton.textContent = originalText;
        }, 1000);

    } catch (e) {
        alert('Ошибка при загрузке файла: ' + e.message);
        initFormaCube(); 
    }
};

document.getElementById('file-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (typeof data !== 'object' || !data.world || !data.camera) {
                     throw new Error("Файл не содержит данных о мире ('world') или камере ('camera').");
                }
                loadWorldFromFile(data);
            } catch (error) {
                alert('Ошибка чтения файла. Убедитесь, что это правильный формат .json. Детали: ' + error.message);
            }
        };
        reader.readAsText(file);
    }
    event.target.value = ''; 
});


const loadLocalState = () => {
    const worldDataString = localStorage.getItem('forma_world_data_local');
    const cameraDataString = localStorage.getItem('forma_camera_data_local');

    if (!worldDataString || !cameraDataString) {
        return false;
    }
    
    const worldData = JSON.parse(worldDataString);
    const cameraData = JSON.parse(cameraDataString);

    if (worldData.length === 0) return false;

    worldData.forEach(cubeData => {
        const position = new THREE.Vector3(...cubeData.position);
        createFormaCube(position, -1, cubeData.faces);
    });

    camera.position.fromArray(cameraData.position);
    controls.target.fromArray(cameraData.target);
    controls.update();
    
    return true; 
};


// --- ЛОГИКА ТАПА И УДЕРЖАНИЯ (без изменений) ---
let tapTimeout;
let longPressTimer;
let tapCount = 0;
const TAP_DELAY = 400; 
const LONG_PRESS_DELAY = 700; 
let isLongPress = false;

renderer.domElement.addEventListener('pointerdown', (event) => {
    if (event.target.closest('.control-button, .top-control, .dir-button')) return;
    event.preventDefault(); 
    
    isLongPress = false;
    clearTimeout(longPressTimer);
    
    longPressTimer = setTimeout(() => {
        isLongPress = true;
        handleLongPress(event); 
    }, LONG_PRESS_DELAY);
});

renderer.domElement.addEventListener('pointerup', (event) => {
    clearTimeout(longPressTimer); 
    
    if (isLongPress) {
        isLongPress = false;
        return; 
    }

    handleInteraction(event);
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (longPressTimer && (Math.abs(event.movementX) > 2 || Math.abs(event.movementY) > 2)) {
        clearTimeout(longPressTimer);
    }
    isLongPress = false;
});


const handleLongPress = (event) => {
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(formaCubeFaces, false);
    
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const obj = intersection.object;
        const group = obj.parent; 

        if (group) {
            group.remove(obj);
            obj.geometry.dispose(); 
        }
        const index = formaCubeFaces.indexOf(obj);
        if (index > -1) {
            formaCubeFaces.splice(index, 1);
        }
        
        if (group && group.children.length === 1 && group.children[0].isLight) {
            scene.remove(group);
            if (group === formaCubeGroup) {
                formaCubeGroup = null;
            }
        }
    }
    
    tapCount = 0; 
};


const handleInteraction = (event) => {
    if (event.target.closest('.control-button, .top-control, .dir-button')) return;
    
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(formaCubeFaces, false);
    const wordSpawnProbability = 0.3;
    
    tapCount++;
    
    if (tapTimeout) clearTimeout(tapTimeout);

    tapTimeout = setTimeout(() => {
        const currentTapCount = tapCount;
        tapCount = 0; 
        
        if (intersects.length > 0) {
            const intersection = intersects[0];
            const obj = intersection.object;
            const group = obj.parent; 

            if (currentTapCount === 2) {
                const faceNormal = intersection.face.normal.clone();
                faceNormal.transformDirection(obj.matrixWorld); 
                faceNormal.normalize();
                
                const groupWorldPos = group.position.clone();
                const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
                
                const excludeId = getOppositeFaceId(faceNormal);
                const newCube = createFormaCube(newGroupPosition, excludeId, FACE_CONFIGS);
                
            } else if (currentTapCount === 1) {
                const face = obj;
                
                if (face.material.opacity === 1.0) {
                    face.material.opacity = 0.5;
                    face.material.envMapIntensity = 0.5; 
                    face.userData.isTransparent = true;
                } else {
                    face.material.opacity = 1.0;
                    face.material.envMapIntensity = 1.0; 
                    face.userData.isTransparent = false;
                }
                face.material.needsUpdate = true;
                
                if (Math.random() < wordSpawnProbability) {
                    const wordPos3D = intersection.point.clone(); 
                    const wordPos2D = wordPos3D.project(camera);
                    const wordX = (wordPos2D.x * 0.5 + 0.5) * window.innerWidth;
                    const wordY = (-wordPos2D.y * 0.5 + 0.5) * window.innerHeight;
                    createSecret(wordX, wordY);
                }
            }
            
        } 
    }, TAP_DELAY);
};

// ... (Word spawning functions, без изменений) ...
function createSecret(x, y) {
    const secret = document.createElement('a');
    secret.className = 'secret';
    const word = secrets[Math.floor(Math.random() * secrets.length)];
    secret.textContent = word;

    secret.target = '_blank';
    secret.style.cssText = `
        position: fixed; left: ${x}px; top: ${y}px; transform: translate(-50%, -50%); opacity: 0;
        font-family: monospace; font-size: 18px; color: white; text-decoration: none;
        padding: 10px; border-radius: 8px; pointer-events: auto; z-index: 1000;
    `;
    document.body.appendChild(secret);

    const rect = secret.getBoundingClientRect();
    const minWordDistance = Math.max(rect.width, rect.height) + 20;
    if (isWordOccupied(x, y, minWordDistance)) {
        secret.remove();
        return;
    }

    activePoints.push({ x, y, timestamp: Date.now(), isWord: true });

    setTimeout(() => {
        secret.style.opacity = 1;
        secret.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 10);

    setTimeout(() => {
        secret.style.opacity = 0;
        secret.style.transform = 'translate(-50%, -50%) scale(0.8)';
    }, 8000);

    setTimeout(() => {
        secret.remove();
        const index = activePoints.findIndex(p => p.x === x && p.y === y && p.isWord);
        if (index !== -1) activePoints.splice(index, 1);
    }, 8500);

    secret.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        if (!e.ctrlKey && !e.metaKey && secret.href === window.location.href + '#') {
            secret.remove();
        }
    });
}

function isWordOccupied(x, y, minDistance) {
    return activePoints.some(point => {
        if (!point.isWord) return false;
        const dx = point.x - x;
        const dy = point.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < minDistance;
    });
}


// --- ЛОГИКА КОЛЛИЗИЙ (РЕШАЕТ ПРОБЛЕМУ С ZOOM/PAN) ---
const applyCameraRepulsion = (startPosition, direction, distanceToMove) => {
    const safeDistance = 0.5; 
    
    if (formaCubeFaces.length === 0) return distanceToMove; 

    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        
        // Возвращаем только то расстояние, которое безопасно для движения
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    
    return Math.abs(distanceToMove); 
};


// Camera movement (Closer/Further/D-Pad)
const moveCamera = (directionVector, distance) => {
    const initialPosition = camera.position.clone();
    
    const direction = directionVector.clone().normalize();
    
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const resetButton = document.querySelector('.reset-button'); 
const flyButton = document.querySelector('.fly-button');
const saveButton = document.querySelector('.save-button'); 
const loadButton = document.querySelector('.load-button');
const fileInput = document.getElementById('file-input');

// --- НОВЫЕ ПЕРЕМЕННЫЕ ДЛЯ D-PAD ---
const upButton = document.querySelector('.dir-up');
const downButton = document.querySelector('.dir-down');
const leftButton = document.querySelector('.dir-left');
const rightButton = document.querySelector('.dir-right');
const STEP_DISTANCE_BUTTON = CUBE_SIZE / 5; // Шаг для кнопок движения (был прерван здесь)


closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    moveCamera(direction, CUBE_SIZE); 
});

// --- ЛОГИКА D-PAD (ИСПРАВЛЕННАЯ: использует локальные векторы камеры для Pan) ---
// Движение ВПРАВО/ВЛЕВО (по оси X в плоскости камеры)
rightButton.addEventListener('click', () => {
    // Вектор Right (X-ось локальной системы камеры)
    const right = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0); 
    moveCamera(right, STEP_DISTANCE_BUTTON);
});

leftButton.addEventListener('click', () => {
    // Вектор Left (Отрицательная X-ось локальной системы камеры)
    const left = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0).negate(); 
    moveCamera(left, STEP_DISTANCE_BUTTON);
});

// Движение ВВЕРХ/ВНИЗ (по оси Y в плоскости камеры)
upButton.addEventListener('click', () => {
    // Вектор Up (Y-ось локальной системы камеры)
    const up = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1);
    moveCamera(up, STEP_DISTANCE_BUTTON);
});

downButton.addEventListener('click', () => {
    // Вектор Down (Отрицательная Y-ось локальной системы камеры)
    const down = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 1).negate();
    moveCamera(down, STEP_DISTANCE_BUTTON);
});
// ---------------------------------


resetButton.addEventListener('click', () => {
    localStorage.removeItem('forma_world_data_local');
    localStorage.removeItem('forma_camera_data_local');
    window.location.reload(); 
});

saveButton.addEventListener('click', saveWorldToFile);

loadButton.addEventListener('click', () => {
    fileInput.click();
});


renderer.domElement.addEventListener('wheel', (event) => {
    
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    
    const distanceStep = 0.5;
    
    if (event.deltaY < 0) { // Скролл вверх (Closer)
        moveCamera(direction, distanceStep); 
    } else if (event.deltaY > 0) { // Скролл вниз (Further)
        direction.negate();
        moveCamera(direction, distanceStep); 
    }

    event.preventDefault();
    controls.update();
});


// --- Обработчик кнопки "Fly" ---
flyButton.addEventListener('click', () => {
    isFlying = !isFlying;
    if (isFlying) {
        flyButton.textContent = 'Stop';
    } else {
        flyButton.textContent = 'Fly';
    }
});
// ----------------------------------------------

// Animation loop (без изменений)
const animate = () => {
    controls.update();

    if (isFlying) {
        currentSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
        currentSpeed = Math.max(currentSpeed - DECCELERATION, 0.0);
    }
    
    if (currentSpeed > 0) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        moveCamera(direction, currentSpeed); 
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};
// ---------------------------------------------

// Resize handling (без изменений)
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ИНИЦИАЛИЗАЦИЯ КУБА
initFormaCube();
animate();

    </script>
</body>
</html>
