<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Space Polarity - Forma Base</title>
    <link rel="manifest" href="manifest.json"> 
    <style>
        body {
            user-select: none; 
            margin: 0;
            overflow: hidden;
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
        }
        body { margin: 0; overflow: hidden; background: #000; }

        .control-button { 
            position: fixed;
            bottom: 20px;
            z-index: 1000;
            cursor: pointer;
            width: 80px; 
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255) !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Further - слева */
        .further-button {
            left: 5%; 
            right: auto;
        }

        /* Start - по центру */
        .start-button {
            left: 50%;
            transform: translateX(-50%);
        }

        /* Closer - справа */
        .closer-button {
            right: 5%; 
            left: auto;
        }
            
        .help-button {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            cursor: pointer;
            width: auto;
            height: auto;
            font-family: monospace;
            font-size: 18px;
            font-weight: normal;
            color: rgba(255, 255, 255) !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }
            
        .hidden {
            display: none;
        }
        .secret {
            position: fixed;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 18px;
            color: white;
            text-decoration: none;
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            z-index: 1000;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

    </style>
</head>
<body>
    <div class="button control-button further-button">Further</div> 
    <div class="button control-button start-button">Start</div> 
    <div class="button control-button closer-button">Closer</div> 

    <a href="https://eugenebox.t.me/" style="text-decoration: none;" class="help-button" target="_blank">Help</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// Imports 
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30; 
const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- ИСТОРИЯ ДЕЙСТВИЙ ---
let history = [];
let historyIndex = -1;
const MAX_HISTORY = 20;
// -------------------------

// Background color change (оставлено без изменений)
const colors = ['#006ee5', '#f84d54', '#000033', '#f84d54'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 5;
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000);

// --- Controls and lights (без изменений) ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;

controls.enableZoom = false;
controls.enablePan = true;
controls.zoomSpeed = 0.5; 
controls.panSpeed = 0.3;  

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);
const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 0.8);
ultramarineLight.position.set(-10, -10, -10);
scene.add(ultramarineLight);
const lights = [
    { color: 0xff0000, position: [10, 0, 0] },
    { color: 0x00ff00, position: [0, 10, 0] },
    { color: 0x0000ff, position: [0, 0, 10] },
    { color: 0x3f00ff, position: [-10, -10, -10] },
];
lights.forEach(({ color, position }) => {
    const light = new THREE.DirectionalLight(color, 0.8);
    light.position.set(...position);
    scene.add(light);
});

// Word-links (оставлено без изменений)
const secrets = ['slowly', 'focus', 'try', 'switch', 'scroll', 'scale', 'shift', 'move', 'tap', 'touch', 'click', 'right', 'button', 'mouse', 'screen', 'fly', 'double', 'follow', 'read', 'peer', 'rest', 'quick', 'hold', 'and', 'or', 'virtual', 'eternity', 'node', 'server', 'idea', 'word', 'victory', 'release', 'keep', 'calm', 'relax', 'rest', 'leave', 'chance', 'mine', 'token', 'visual', 'reality', 'space', 'polarity', 'keep', 'mind', 'think', 'dream', 'fantasy', 'trade', 'change', 'place', 'invest', 'look', 'ask', 'find', 'sign', 'type', 'play', 'experiment', 'phenomena', 'coordinate', 'carry', 'spend', 'accept', 'bring', 'transfer', 'take', 'sell', 'market', 'stay', 'well', 'top', 'hit'];


// Object storage
let formaCubeFaces = []; 
const activePoints = [];
const collisionRaycaster = new THREE.Raycaster();

// --- ЛОГИКА КУБА ИЗ 6 ГРАНЕЙ (Forma Base) ---
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 

// КОНФИГУРАЦИЯ ГРАНЕЙ
// Идентификаторы граней:
// 0: +X, 1: -X, 2: +Y, 3: -Y, 4: +Z, 5: -Z
const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },     
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },    
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },    
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },    
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },             
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },      
];

// Функция для определения, какую грань исключить при "наращивании"
const getOppositeFaceId = (normal) => {
    let bestMatchId = -1;
    // Находим грань, чья нормаль наиболее противоположна нормали тапа
    let minDot = Infinity; 

    FACE_CONFIGS.forEach(config => {
        // Скалярное произведение (Dot Product). 
        // Если векторы противоположны (смотрит один на другой), dot product = -1.
        const dot = config.normal.dot(normal);
        
        if (dot < minDot) {
            minDot = dot;
            bestMatchId = config.id;
        }
    });
    
    // Возвращаем ID грани, чья нормаль наиболее противоположна нормали тапа.
    // Это будет та грань нового куба, которая окажется "внутри" старого,
    // и которую, следовательно, надо исключить.
    return bestMatchId;
};


const createFormaCube = (position, excludeIndex = -1) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);

    FACE_CONFIGS.forEach((config, index) => {
        if (config.id === excludeIndex) return; // Используем ID для исключения

        const material = new THREE.MeshStandardMaterial({
            color: config.color,
            roughness: 0.5,
            metalness: 0.5,
            side: THREE.DoubleSide, 
        });
        
        const face = new THREE.Mesh(faceGeometry, material);
        face.position.set(...config.pos);
        face.rotation.set(...config.rot);
        face.name = `face_${config.id}`; 
        
        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    return newFormaCubeGroup;
};

const initFormaCube = (position = new THREE.Vector3(0, 0, camera.position.z - 15)) => {
    // Удаляем старые объекты, если они есть
    if (formaCubeGroup) {
        scene.remove(formaCubeGroup);
        formaCubeFaces.forEach(face => face.geometry.dispose());
        formaCubeFaces = [];
        formaCubeGroup = null;
    }
    // Создаем новый куб (все 6 граней)
    formaCubeGroup = createFormaCube(position, -1); 
    controls.target.set(position.x, position.y, position.z); 
    controls.update();
    
    // Сохраняем начальное состояние
    saveState();
}
// --- КОНЕЦ ЛОГИКИ КУБА ---


// --- ЛОГИКА ИСТОРИИ И СОСТОЯНИЯ (без изменений) ---

const saveState = () => {
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }

    const groupsData = [];
    scene.traverse(obj => {
        if (obj.isGroup && obj.name !== 'wordGroup') { 
            const facesData = obj.children
                .filter(child => child.isMesh && child.name.startsWith('face_'))
                .map(face => ({
                    id: parseInt(face.name.split('_')[1]),
                    position: face.position.clone(),
                    rotation: face.rotation.clone(),
                    color: face.material.color.getHex()
                }));
            
            if (facesData.length > 0) {
                 groupsData.push({
                    position: obj.position.clone(),
                    faces: facesData
                });
            }
        }
    });

    const newState = {
        cameraPos: camera.position.clone(),
        controlsTarget: controls.target.clone(),
        groups: groupsData
    };
    
    if (history.length >= MAX_HISTORY) {
        history.shift();
    } else {
        historyIndex++;
    }
    history[historyIndex] = newState;
};

const restoreState = (index) => {
    if (index < 0 || index >= history.length) return;
    
    const state = history[index];
    
    // 1. Удаляем все текущие грани и группы
    formaCubeFaces.forEach(face => face.geometry.dispose());
    formaCubeFaces.length = 0;
    scene.children
        .filter(obj => obj.isGroup && obj.name !== 'wordGroup')
        .forEach(group => scene.remove(group));
    formaCubeGroup = null; 

    // 2. Восстанавливаем объекты (группы и грани)
    state.groups.forEach(groupData => {
        const newGroup = new THREE.Group();
        newGroup.position.copy(groupData.position);
        
        groupData.faces.forEach(faceData => {
            const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
            const material = new THREE.MeshStandardMaterial({
                color: faceData.color,
                roughness: 0.5,
                metalness: 0.5,
                side: THREE.DoubleSide, 
            });
            
            const face = new THREE.Mesh(faceGeometry, material);
            face.position.copy(faceData.position);
            face.rotation.copy(faceData.rotation);
            face.name = `face_${faceData.id}`;
            
            newGroup.add(face);
            formaCubeFaces.push(face);
        });
        
        scene.add(newGroup);
        if (state.groups.indexOf(groupData) === 0) {
            formaCubeGroup = newGroup;
        }
    });

    // 3. Восстанавливаем позицию камеры и таргет контролов
    camera.position.copy(state.cameraPos);
    controls.target.copy(state.controlsTarget);
    controls.update();

    historyIndex = index;
};

const undo = () => {
    if (historyIndex > 0) {
        restoreState(historyIndex - 1);
    }
};

const redo = () => {
    if (historyIndex < history.length - 1) {
        restoreState(historyIndex + 1);
    }
};

// --- КОНЕЦ ЛОГИКИ ИСТОРИИ ---


// --- ЛОГИКА ОБРАБОТКИ ТАПОВ (Обновлено) ---
let tapTimeout;
let tapCount = 0;
const TAP_DELAY = 400; 

const handleInteraction = (event) => {
    if (event.target.closest('.control-button, .help-button')) return;
    event.preventDefault(); 
    
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(formaCubeFaces, false);
    const wordSpawnProbability = 0.3;
    
    tapCount++;
    
    if (tapTimeout) clearTimeout(tapTimeout);

    tapTimeout = setTimeout(() => {
        const currentTapCount = tapCount;
        tapCount = 0; 
        
        if (intersects.length > 0) {
            // --- ТАП НА ГРАНЬ ---
            const intersection = intersects[0];
            const obj = intersection.object;
            const group = obj.parent; 

            if (currentTapCount === 2) {
                // ДВОЙНОЙ ТАП НА ГРАНЬ: Наращивание нового куба
                
                // 1. Получаем нормаль грани в мировых координатах
                const faceNormal = intersection.face.normal.clone();
                faceNormal.transformDirection(obj.matrixWorld); 
                faceNormal.normalize();
                
                // 2. Рассчитываем новую позицию для центра новой группы
                // Новая позиция = (Центр старой группы) + (Нормаль грани * CUBE_SIZE)
                // Группа уже находится в мировых координатах
                const groupWorldPos = group.position.clone();
                const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
                
                // 3. Определяем, какую грань нового куба исключить (ту, что смотрит назад)
                // *faceNormal* - это нормаль существующей грани, смотрящая наружу.
                // *Исключаемая грань* нового куба должна смотреть в противоположную сторону (назад).
                const excludeId = getOppositeFaceId(faceNormal);

                // 4. Создаем новый куб, приклеенный к старому
                createFormaCube(newGroupPosition, excludeId);
                
                saveState();
                
            } else if (currentTapCount === 1) {
                // ОДИНОЧНЫЙ ТАП НА ГРАНЬ: Удаление отдельной грани
                
                // 1. Удаление грани
                if (group) {
                    group.remove(obj);
                    obj.geometry.dispose(); 
                }
                const index = formaCubeFaces.indexOf(obj);
                if (index > -1) {
                    formaCubeFaces.splice(index, 1);
                }
                
                // 2. Проверка удаления группы
                if (group.children.length === 0) {
                    scene.remove(group);
                    if (group === formaCubeGroup) {
                        formaCubeGroup = null;
                    }
                }

                // 3. Спаун слова
                if (Math.random() < wordSpawnProbability) {
                    const wordPos3D = intersection.point.clone(); 
                    const wordPos2D = wordPos3D.project(camera);
                    const wordX = (wordPos2D.x * 0.5 + 0.5) * window.innerWidth;
                    const wordY = (-wordPos2D.y * 0.5 + 0.5) * window.innerHeight;
                    createSecret(wordX, wordY);
                }
                
                saveState();
            }
            
        } else {
            // --- ТАП ВНЕ ГРАНЕЙ (UNDO/REDO) ---
            if (currentTapCount === 2) {
                // ДВОЙНОЙ ТАП ВНЕ ГРАНЕЙ: UNDO
                undo();
            } else if (currentTapCount === 3) {
                // ТРОЙНОЙ ТАП ВНЕ ГРАНЕЙ: REDO
                redo();
            }
        }
    }, TAP_DELAY);
};

// ... (Word spawning functions, опущено для краткости) ...
function createSecret(x, y) {
    const secret = document.createElement('a');
    secret.className = 'secret';
    const word = secrets[Math.floor(Math.random() * secrets.length)];
    secret.textContent = word;

    secret.target = '_blank';
    secret.style.cssText = `
        position: fixed; left: ${x}px; top: ${y}px; transform: translate(-50%, -50%); opacity: 0;
        font-family: monospace; font-size: 18px; color: white; text-decoration: none;
        padding: 10px; border-radius: 8px; pointer-events: auto; z-index: 1000;
    `;
    document.body.appendChild(secret);

    const rect = secret.getBoundingClientRect();
    const minWordDistance = Math.max(rect.width, rect.height) + 20;
    if (isWordOccupied(x, y, minWordDistance)) {
        secret.remove();
        return;
    }

    activePoints.push({ x, y, timestamp: Date.now(), isWord: true });

    setTimeout(() => {
        secret.style.opacity = 1;
        secret.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 10);

    setTimeout(() => {
        secret.style.opacity = 0;
        secret.style.transform = 'translate(-50%, -50%) scale(0.8)';
    }, 8000);

    setTimeout(() => {
        secret.remove();
        const index = activePoints.findIndex(p => p.x === x && p.y === y && p.isWord);
        if (index !== -1) activePoints.splice(index, 1);
    }, 8500);

    secret.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        if (!e.ctrlKey && !e.metaKey && secret.href === window.location.href + '#') {
            secret.remove();
        }
    });
}

function isWordOccupied(x, y, minDistance) {
    return activePoints.some(point => {
        if (!point.isWord) return false;
        const dx = point.x - x;
        const dy = point.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < minDistance;
    });
}
// ... (конец Word spawning functions) ...


// --- ЛОГИКА КОЛЛИЗИЙ (без изменений) ---

const applyCameraRepulsion = (startPosition, direction, distanceToMove) => {
    const safeDistance = 0.5; 
    
    if (formaCubeFaces.length === 0) return distanceToMove; 

    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    
    return Math.abs(distanceToMove); 
};


// Camera movement (Closer/Further)
const moveCamera = (directionVector, distance) => {
    const initialPosition = camera.position.clone();
    
    const direction = directionVector.clone().normalize();
    
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const startButton = document.querySelector('.start-button'); 

closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    moveCamera(direction, CUBE_SIZE); 
});

startButton.addEventListener('click', () => {
    initFormaCube(); 
});


renderer.domElement.addEventListener('wheel', (event) => {
    if (event.deltaY < 0) { 
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        const initialPosition = camera.position.clone();
        
        const currentDistanceToCenter = camera.position.distanceTo(controls.target);

        if (currentDistanceToCenter < 1 || applyCameraRepulsion(initialPosition, direction, 0.5) < 0.01) { 
            event.preventDefault(); 
            return;
        }
    }
    
    controls.update();
});


// Interaction handling (заменено на handleInteraction)
renderer.domElement.addEventListener('pointerdown', handleInteraction);


// Animation loop
const animate = () => {
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};

// Resize handling (оставлено без изменений)
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ИНИЦИАЛИЗАЦИЯ КУБА
initFormaCube();
animate();

    </script>
</body>
</html>
