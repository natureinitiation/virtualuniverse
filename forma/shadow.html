// ... (Остальная часть кода HTML и стилей остается без изменений)

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script>

// --- Imports & Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x007bff);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30; 

let previousCameraPosition = new THREE.Vector3().copy(camera.position);

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.shadowMap.enabled = true; // Начальное состояние: Тени ВКЛ
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Настройки полета ---
let isFlying = false;
let currentSpeed = 0.0;             
const MAX_SPEED = 0.3;              
const ACCELERATION = 0.00033;       
const DECCELERATION = 0.00033;      

// --- Background Animation ---
const colors = ['#006ee5', '#000033'];
let currentColorIndex = 0;
function changeBackgroundColor() {
    currentColorIndex = (currentColorIndex + 1) % colors.length;
    const targetColor = new THREE.Color(colors[currentColorIndex]);
    animateBackgroundColor(targetColor);
}
function animateBackgroundColor(targetColor) {
    const startColor = scene.background.clone();
    const duration = 60; 
    const startTime = performance.now();
    function updateBackgroundColor() {
        const elapsed = (performance.now() - startTime) / 1000;
        const progress = Math.min(elapsed / duration, 1);
        scene.background.lerpColors(startColor, targetColor, progress);
        if (progress < 1) requestAnimationFrame(updateBackgroundColor);
    }
    updateBackgroundColor();
}
setInterval(changeBackgroundColor, 100000); 

// --- Controls & Lights ---
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.005;
controls.enableZoom = true; 
controls.zoomSpeed = 0.5; 
controls.enablePan = true;
controls.panSpeed = 0.3;  

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
scene.add(ambientLight);

const cameraLightGroup = new THREE.Group();
camera.add(cameraLightGroup); 
scene.add(camera); 

// Уменьшена интенсивность для более светлых (полупрозрачных) теней до 0.8
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(0, 0, 10); 
directionalLight.castShadow = true; 

directionalLight.shadow.mapSize.width = 2048; 
directionalLight.shadow.mapSize.height = 2048; 
directionalLight.shadow.camera.near = 0.5;
// Уменьшена дальность и область видимости теневой камеры для фокусировки
directionalLight.shadow.camera.far = 30; 
directionalLight.shadow.camera.left = -10; 
directionalLight.shadow.camera.right = 10; 
directionalLight.shadow.camera.top = 10; 
directionalLight.shadow.camera.bottom = -10;
cameraLightGroup.add(directionalLight);

const ultramarineLight = new THREE.DirectionalLight(0x3f00ff, 1.0);
ultramarineLight.position.set(0, 0, -10); 
ultramarineLight.castShadow = false; 
cameraLightGroup.add(ultramarineLight);

// --- СПИСОК СЛОВ (ОТКЛЮЧЕН) ---
const secrets = []; 

// --- Object Logic ---
let formaCubeFaces = []; 
const activePoints = [];
const collisionRaycaster = new THREE.Raycaster();
let formaCubeGroup = null; 
const CUBE_SIZE = 5; 

function addInternalLights(group) {
    const warmInternalLight = new THREE.PointLight(0xffaa00, 0.01, 0); 
    warmInternalLight.position.set(0, 0, 0); 
    group.add(warmInternalLight);
}

const FACE_CONFIGS = [
    { color: 0xff0000, pos: [CUBE_SIZE/2, 0, 0], rot: [0, Math.PI / 2, 0], id: 0, normal: new THREE.Vector3(1, 0, 0) },      
    { color: 0x00ff00, pos: [-CUBE_SIZE/2, 0, 0], rot: [0, -Math.PI / 2, 0], id: 1, normal: new THREE.Vector3(-1, 0, 0) },      
    { color: 0x0000ff, pos: [0, CUBE_SIZE/2, 0], rot: [-Math.PI / 2, 0, 0], id: 2, normal: new THREE.Vector3(0, 1, 0) },      
    { color: 0xffff00, pos: [0, -CUBE_SIZE/2, 0], rot: [Math.PI / 2, 0, 0], id: 3, normal: new THREE.Vector3(0, -1, 0) },      
    { color: 0x00ffff, pos: [0, 0, CUBE_SIZE/2], rot: [0, 0, 0], id: 4, normal: new THREE.Vector3(0, 0, 1) },              
    { color: 0xff00ff, pos: [0, 0, -CUBE_SIZE/2], rot: [0, Math.PI, 0], id: 5, normal: new THREE.Vector3(0, 0, -1) },        
];

const getOppositeFaceId = (normal) => {
    let bestMatchId = -1;
    let minDot = Infinity; 
    FACE_CONFIGS.forEach(config => {
        const dot = config.normal.dot(normal); 
        if (dot < minDot) {
            minDot = dot;
            bestMatchId = config.id;
        }
    });
    return bestMatchId;
};

const createCubeFace = (config) => {
    const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshStandardMaterial({
        color: config.color, 
        roughness: 0.5,      
        metalness: 1.0,      
        side: THREE.DoubleSide, 
        transparent: true, 
        opacity: 1.0,        
        envMap: scene.background, 
    });
    
    const face = new THREE.Mesh(faceGeometry, material);
    face.castShadow = true;    
    face.receiveShadow = true; 
    face.position.set(...config.pos);
    face.rotation.set(...config.rot);
    face.name = `face_${config.id}`; 
    face.userData = { 
        id: config.id, 
        originalColor: config.color,
        isTransparent: false
    };
    return face;
}

const createFormaCube = (position, excludeIndex = -1, loadedFacesState = FACE_CONFIGS) => {
    const newFormaCubeGroup = new THREE.Group();
    newFormaCubeGroup.position.copy(position);
    newFormaCubeGroup.userData.isFormaCube = true;

    FACE_CONFIGS.forEach((baseConfig) => {
        if (baseConfig.id === excludeIndex) return;
        const faceState = loadedFacesState.find(f => f.id === baseConfig.id);
        if (loadedFacesState !== FACE_CONFIGS && !faceState) return;

        const face = createCubeFace(baseConfig);
        if (faceState && faceState.isTransparent) {
             face.material.opacity = 0.5;
             face.material.envMapIntensity = 0.5;
             face.userData.isTransparent = true;
        }
        newFormaCubeGroup.add(face);
        formaCubeFaces.push(face); 
    });
    
    scene.add(newFormaCubeGroup);
    addInternalLights(newFormaCubeGroup); 
    return newFormaCubeGroup;
};

const clearWorld = () => {
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            object.children.filter(child => child.isLight).forEach(light => object.remove(light));
            scene.remove(object);
            object.children.forEach(mesh => {
                if (mesh.isMesh) {
                    mesh.geometry.dispose();
                    if (mesh.material.length) {
                        mesh.material.forEach(m => m.dispose());
                    } else {
                        mesh.material.dispose();
                    }
                }
            });
        }
    });
    formaCubeFaces = [];
    formaCubeGroup = null;
}

const initFormaCube = (position = new THREE.Vector3(0, 0, camera.position.z - 15)) => {
    clearWorld(); 
    const localLoaded = loadLocalState();
    if (!localLoaded) {
        formaCubeGroup = createFormaCube(position, -1); 
    }
    controls.target.set(camera.position.x, camera.position.y, camera.position.z - 15); 
    controls.update();
    
    previousCameraPosition.copy(camera.position);
};

// --- Save/Load Logic ---
const getWorldData = () => {
    const worldData = [];
    scene.traverse(object => {
        if (object.userData.isFormaCube) {
            const cubeData = {
                position: object.position.toArray(),
                faces: []
            };
            object.children.forEach(face => {
                if (face.isMesh && face.userData.id !== undefined) {
                    cubeData.faces.push({
                        id: face.userData.id,
                        isTransparent: face.userData.isTransparent
                    });
                }
            });
            if (cubeData.faces.length > 0) worldData.push(cubeData);
        }
    });
    const cameraData = {
        position: camera.position.toArray(),
        target: controls.target.toArray()
    };
    return { world: worldData, camera: cameraData };
};

const saveWorldToFile = () => {
    const data = getWorldData();
    const json = JSON.stringify(data, null, 2); 
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'forma_world_' + Date.now() + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    const saveButton = document.querySelector('.save-button');
    const originalText = saveButton.textContent;
    saveButton.textContent = 'Saved!';
    setTimeout(() => { saveButton.textContent = originalText; }, 1000);
    
    localStorage.setItem('forma_world_data_local', JSON.stringify(data.world));
    localStorage.setItem('forma_camera_data_local', JSON.stringify(data.camera));
};

const loadWorldFromFile = (data) => {
    clearWorld();
    try {
        const worldData = data.world;
        const cameraData = data.camera;
        if (!worldData || !cameraData || !Array.isArray(worldData)) throw new Error("Format Error");

        worldData.forEach(cubeData => {
            const position = new THREE.Vector3(...cubeData.position);
            createFormaCube(position, -1, cubeData.faces); 
        });

        camera.position.fromArray(cameraData.position);
        controls.target.fromArray(cameraData.target);
        controls.update();
        previousCameraPosition.copy(camera.position); 

        const loadButton = document.querySelector('.load-button');
        const originalText = loadButton.textContent;
        loadButton.textContent = 'Loaded!';
        setTimeout(() => { loadButton.textContent = originalText; }, 1000);

    } catch (e) {
        alert('Load Error: ' + e.message);
        initFormaCube();
    }
};

document.getElementById('file-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                loadWorldFromFile(data);
            } catch (error) {
                alert('JSON Error: ' + error.message);
            }
        };
        reader.readAsText(file);
    }
    event.target.value = ''; 
});

const loadLocalState = () => {
    const worldDataString = localStorage.getItem('forma_world_data_local');
    const cameraDataString = localStorage.getItem('forma_camera_data_local');
    if (!worldDataString || !cameraDataString) return false;
    
    const worldData = JSON.parse(worldDataString);
    const cameraData = JSON.parse(cameraDataString);
    if (worldData.length === 0) return false;

    worldData.forEach(cubeData => {
        const position = new THREE.Vector3(...cubeData.position);
        createFormaCube(position, -1, cubeData.faces);
    });

    camera.position.fromArray(cameraData.position);
    controls.target.fromArray(cameraData.target);
    controls.update();
    previousCameraPosition.copy(camera.position); 
    
    return true; 
};

// --- Interactions ---
let tapTimeout;
let longPressTimer;
let tapCount = 0;
const TAP_DELAY = 400; 
const LONG_PRESS_DELAY = 700; 
let isLongPress = false;

renderer.domElement.addEventListener('pointerdown', (event) => {
    if (event.target.closest('.control-button, .top-control, .mid-control')) return;
    event.preventDefault(); 
    isLongPress = false;
    clearTimeout(longPressTimer);
    longPressTimer = setTimeout(() => {
        isLongPress = true;
        handleLongPress(event); 
    }, LONG_PRESS_DELAY);
});

renderer.domElement.addEventListener('pointerup', (event) => {
    clearTimeout(longPressTimer); 
    if (isLongPress) {
        isLongPress = false;
        return; 
    }
    handleInteraction(event);
});

renderer.domElement.addEventListener('pointermove', (event) => {
    if (longPressTimer) clearTimeout(longPressTimer);
    isLongPress = false;
});

const handleLongPress = (event) => {
    // Логика удаления грани удалена.
    tapCount = 0; 
};

const handleInteraction = (event) => {
    if (event.target.closest('.control-button, .top-control, .mid-control')) return;
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;
    const mouse = new THREE.Vector2((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(formaCubeFaces, false);
    
    tapCount++;
    if (tapTimeout) clearTimeout(tapTimeout);

    tapTimeout = setTimeout(() => {
        const currentTapCount = tapCount;
        tapCount = 0; 
        
        if (intersects.length > 0) {
            const intersection = intersects[0];
            const obj = intersection.object;
            const group = obj.parent; 

            if (currentTapCount === 2) {
                // Логика двойного тапа (добавление куба) сохранена
                const faceNormal = intersection.face.normal.clone();
                faceNormal.transformDirection(obj.matrixWorld); 
                faceNormal.normalize();
                
                const groupWorldPos = group.position.clone();
                const newGroupPosition = groupWorldPos.clone().add(faceNormal.clone().multiplyScalar(CUBE_SIZE));
                
                const excludeId = getOppositeFaceId(faceNormal);
                const newCube = createFormaCube(newGroupPosition, excludeId, FACE_CONFIGS);
                
            } 
            // Логика одиночного тапа (переключение прозрачности) удалена
        } 
    }, TAP_DELAY);
};


// --- Collision Logic (Rotation/Movement) ---
function checkMovementCollision() {
    if (formaCubeFaces.length === 0) return;

    const movementDirection = new THREE.Vector3();
    movementDirection.subVectors(camera.position, previousCameraPosition);
    
    const distanceMoved = movementDirection.length();

    if (distanceMoved < 0.001) return;

    movementDirection.normalize();

    collisionRaycaster.set(previousCameraPosition, movementDirection);
    collisionRaycaster.far = distanceMoved + 0.1; 

    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const safeOffset = 0.1; 
        const safePosition = hit.point.clone().sub(movementDirection.multiplyScalar(safeOffset));
        
        camera.position.copy(safePosition);
    }

    previousCameraPosition.copy(camera.position);
}


// --- Movement Logic (Buttons) ---
const applyCameraRepulsion = (startPosition, direction, distanceToMove) => {
    const safeDistance = 0.5; 
    if (formaCubeFaces.length === 0) return distanceToMove; 
    collisionRaycaster.set(startPosition, direction);
    collisionRaycaster.far = Math.abs(distanceToMove) + safeDistance; 
    const intersects = collisionRaycaster.intersectObjects(formaCubeFaces, false);
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const distToIntersection = intersection.distance;
        if (distToIntersection < Math.abs(distanceToMove) + safeDistance) {
            return Math.max(0, distToIntersection - safeDistance);
        }
    }
    return Math.abs(distanceToMove); 
};

const moveCamera = (directionVector, distance) => {
    const initialPosition = camera.position.clone();
    const direction = directionVector.clone().normalize();
    const actualStepDistance = applyCameraRepulsion(initialPosition, direction, distance);
    if (actualStepDistance > 0) {
        camera.position.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.target.add(direction.clone().multiplyScalar(actualStepDistance));
        controls.update(); 
    }
};

const closerButton = document.querySelector('.closer-button');
const furtherButton = document.querySelector('.further-button');
const resetButton = document.querySelector('.reset-button'); 
const flyButton = document.querySelector('.fly-button');
const saveButton = document.querySelector('.save-button'); 
const loadButton = document.querySelector('.load-button');
const fileInput = document.getElementById('file-input');
const shadowsButton = document.querySelector('.shadows-button'); 

closerButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    moveCamera(direction, CUBE_SIZE); 
});

furtherButton.addEventListener('click', () => {
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction); 
    direction.negate(); 
    moveCamera(direction, CUBE_SIZE); 
});

resetButton.addEventListener('click', () => {
    localStorage.removeItem('forma_world_data_local'); 
    localStorage.removeItem('forma_camera_data_local');
    window.location.reload(); 
});

saveButton.addEventListener('click', saveWorldToFile); 
loadButton.addEventListener('click', () => { fileInput.click(); });

flyButton.addEventListener('click', () => {
    isFlying = !isFlying;
    flyButton.textContent = isFlying ? 'Stop' : 'Fly';
});

// Логика для кнопки Shadows: переключение Shadow / Light
shadowsButton.addEventListener('click', () => {
    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
    directionalLight.castShadow = renderer.shadowMap.enabled; 
    
    // Обновляем текст кнопки: "Shadow" (если включено) или "Light" (если выключено)
    shadowsButton.textContent = renderer.shadowMap.enabled ? 'Shadow' : 'Light';
});

// --- Animation Loop ---
const animate = () => {
    controls.update();

    checkMovementCollision();

    if (isFlying) {
        currentSpeed = Math.min(currentSpeed + ACCELERATION, MAX_SPEED);
    } else {
        currentSpeed = Math.max(currentSpeed - DECCELERATION, 0.0);
    }
    
    if (currentSpeed > 0) {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction); 
        moveCamera(direction, currentSpeed); 
    }
    
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('orientationchange', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

initFormaCube();
animate();

    </script>
</body>
</html>
